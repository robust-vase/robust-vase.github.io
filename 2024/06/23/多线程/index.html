<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>多线程 | 花瓶的博客</title><meta name="author" content="花瓶"><meta name="copyright" content="花瓶"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言 多线程的学习，说实话我也不知道有什么用，其实我能用到的无非就是一个概念thread函数，然后再结合算法进行应用。而这种简单的应用成本几乎只需要一个小时了解一下概念就可以，根本不需要大费周章去完完整整的看视频进行学习。或许后续的编程学习会让我更加的深入？总之还是待观望。 参考博客              基本概念 并发   定义：并发是指两个或更多的任务（独立的活动）在同一时间段内交替进行。">
<meta property="og:type" content="article">
<meta property="og:title" content="多线程">
<meta property="og:url" content="http://example.com/2024/06/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="花瓶的博客">
<meta property="og:description" content="前言 多线程的学习，说实话我也不知道有什么用，其实我能用到的无非就是一个概念thread函数，然后再结合算法进行应用。而这种简单的应用成本几乎只需要一个小时了解一下概念就可以，根本不需要大费周章去完完整整的看视频进行学习。或许后续的编程学习会让我更加的深入？总之还是待观望。 参考博客              基本概念 并发   定义：并发是指两个或更多的任务（独立的活动）在同一时间段内交替进行。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/The_Nightwatch.jpg">
<meta property="article:published_time" content="2024-06-23T13:52:30.000Z">
<meta property="article:modified_time" content="2024-06-23T13:58:38.817Z">
<meta property="article:author" content="花瓶">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="多线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/The_Nightwatch.jpg"><link rel="shortcut icon" href="/img/kele.png"><link rel="canonical" href="http://example.com/2024/06/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":1500,"position":"top","messagePrev":"这篇文章已经有","messageNext":"未更新，花瓶里没有保鲜剂"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":250},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '多线程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-23 21:58:38'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/icon.css"><link rel="stylesheet" href="/css/custom.css"><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async data-pjax src="/js/map.js"></script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="/css/pace.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/lazyload.gif" data-original="/img/John_King.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouye"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw iconfont icon-wenzhang"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijian"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></li><li><a class="site-page child" href="/charts/"><i class="fa-fw iconfont icon-tongji"></i><span> 统计</span></a></li></ul></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw iconfont icon-shejiao"></i><span> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/daily/"><i class="fa-fw iconfont icon-xiaoxi"></i><span> 日常说说</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/knowme/"><i class="fa-fw iconfont icon-mingpian"></i><span> 认识花瓶</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw iconfont icon-liuyanban"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/The_Nightwatch.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="花瓶的博客"><span class="site-name">花瓶的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouye"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw iconfont icon-wenzhang"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijian"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></li><li><a class="site-page child" href="/charts/"><i class="fa-fw iconfont icon-tongji"></i><span> 统计</span></a></li></ul></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw iconfont icon-shejiao"></i><span> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/daily/"><i class="fa-fw iconfont icon-xiaoxi"></i><span> 日常说说</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/knowme/"><i class="fa-fw iconfont icon-mingpian"></i><span> 认识花瓶</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw iconfont icon-liuyanban"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">多线程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-23T13:52:30.000Z" title="发表于 2024-06-23 21:52:30">2024-06-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-23T13:58:38.817Z" title="更新于 2024-06-23 21:58:38">2024-06-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>69分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="多线程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>前言</h1>
<p>多线程的学习，说实话我也不知道有什么用，其实我能用到的无非就是一个概念<code>thread</code>函数，然后再结合算法进行应用。而这种简单的应用成本几乎只需要一个小时了解一下概念就可以，根本不需要大费周章去完完整整的看视频进行学习。或许后续的编程学习会让我更加的深入？总之还是待观望。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43863869/category_12378798.html">参考博客</a></p>
<div align="center" class="aspect-ratio">
    <iframe src="//player.bilibili.com/player.html?isOutside=true&aid=49288732&bvid=BV1Yb411L7ak&cid=229568814&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" high_quality="1" danmaku="1" allowfullscreen="true"> 
    </iframe>
</div>
<h1>基本概念</h1>
<h2 id="并发">并发</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>定义</strong>：并发是指两个或更多的任务（独立的活动）在同一时间段内交替进行。具体来说，就是一个程序可以同时执行多个独立的任务。</p>
</li>
<li class="lvl-2">
<p><strong>单核 CPU 并发</strong>：在过去，计算机使用单核 CPU（中央处理器），在某一时刻只能执行一个任务。操作系统通过调度程序实现任务切换（上下文切换），使得看起来像是多个任务同时进行，但实际上每个任务在短时间内交替执行。任务切换时需要保存变量状态和执行进度，这会产生时间开销。</p>
</li>
<li class="lvl-2">
<p><strong>多核 CPU 并发</strong>：随着硬件的发展，出现了多处理器计算机，特别是在服务器和高性能计算领域。台式机中的多核 CPU（一个 CPU 内有多个运算核心）可以实现真正的并行处理，对操作系统来说，每个核心被视为独立的 CPU。这样，多个任务可以在不同的核心上同时执行，实现真正的并发。</p>
</li>
<li class="lvl-2">
<p><strong>并发的目的</strong>：使用并发的主要目的是同时处理多个任务，以提高系统性能和效率。</p>
</li>
</ul>
<h2 id="可执行的程序">可执行的程序</h2>
<p><strong>定义</strong>：可执行程序是一个可以被计算机执行的文件。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>Windows</strong>：可执行程序的扩展名为 <code>.exe</code>。</p>
</li>
<li class="lvl-2">
<p><strong>Linux</strong>：可以通过 <code>ls -la</code> 命令查看文件权限，具有 <code>rwx</code>（可读、可写、可执行）权限的文件是可执行文件。</p>
</li>
</ul>
<h2 id="进程">进程</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>定义</strong>：进程是一个运行中的可执行程序。在 Windows 上，可以通过双击可执行文件启动进程；在 Linux 上，可以使用 <code>./文件名</code> 启动进程。</p>
</li>
<li class="lvl-2">
<p>当一个可执行程序运行起来后，就创建了一个进程。因此，<mark>进程就是运行中的可执行程序</mark>。</p>
</li>
</ul>
<h2 id="线程">线程</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>主线程</strong>：每个进程（即运行中的可执行程序）都有一个唯一的主线程。当执行可执行程序时，产生一个进程，同时主线程随之启动。主线程负责执行 <code>main</code> 函数中的代码。</p>
</li>
<li class="lvl-2">
<p><strong>线程的作用</strong>：线程是用来执行代码的。可以把线程理解为一条代码执行的通路。</p>
</li>
<li class="lvl-2">
<p><strong>创建新线程</strong>：除了主线程外，还可以通过编程创建其他线程。每个新线程都可以执行不同的代码路径，这意味着在同一时刻可以处理多个不同的任务。</p>
</li>
<li class="lvl-2">
<p><strong>线程数量的限制</strong>：线程数量并不是越多越好。每个线程需要独立的堆栈空间（大约 1MB），线程之间的切换需要保存很多中间状态，这些切换操作会耗费系统资源。因此，<mark>创建过多的线程会影响程序的性能</mark>。</p>
</li>
</ul>
<h1>创建多线程</h1>
<p>头文件：<code>#include &lt;thread&gt;</code></p>
<h2 id="使用函数对象创建线程">使用函数对象创建线程</h2>
<p><code>thread</code>创建了线程<code>mytobj</code>，线程执行起点（入口）是<code>myPrint</code>。</p>
<p><code>join</code>意为汇合，<mark>子线程和主线程汇合</mark>。<code>join()</code>一般用于阻塞主线程，使得主线程需要等待子线程执行完毕才结束；</p>
<p><code>detach()</code>函数会将与主线程关联的<code>thread</code>对象失去与主线程的关联，该子线程会留驻在后台运行。<s>脱缰野马</s></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myprint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;This is my thread.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;线程中输出 i^2 &quot;</span> &lt;&lt; i * i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;My thread is finished&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">thread <span class="title">mytobj</span><span class="params">(myprint)</span></span>;</span><br><span class="line"></span><br><span class="line">	mytobj.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">// mytobj.detach();</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;BeiJing welcomes me?&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;主线程中输出 -i^2 &quot;</span> &lt;&lt; -i * i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>mytobj.join();</code>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">This is my thread.</span><br><span class="line">线程中输出 i^2 0</span><br><span class="line">线程中输出 i^2 1</span><br><span class="line">线程中输出 i^2 4</span><br><span class="line">线程中输出 i^2 9</span><br><span class="line">线程中输出 i^2 16</span><br><span class="line">My thread is finished</span><br><span class="line">BeiJing welcomes me?</span><br><span class="line">主线程中输出 -i^2 0</span><br><span class="line">主线程中输出 -i^2 -1</span><br><span class="line">主线程中输出 -i^2 -4</span><br><span class="line">主线程中输出 -i^2 -9</span><br><span class="line">主线程中输出 -i^2 -16</span><br></pre></td></tr></table></figure>
<p><code>mytobj.detach();</code>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BeiJing welcomes me?</span><br><span class="line">主线程中输出 -i^2 0</span><br><span class="line">主线程中输出 -i^2 -1</span><br><span class="line">主线程中输出 -i^2 -4</span><br><span class="line">主线程中输出 -i^2 -9</span><br><span class="line">主线程中输出 -i^2 This is my thread.</span><br><span class="line">线程中输出 i^2 0</span><br><span class="line">线程中输出 i^2 1</span><br><span class="line">线程中输出 i^2 4</span><br><span class="line">线程中输出 i^2 9</span><br><span class="line">线程中输出 i^2 16</span><br><span class="line">My thread is finished</span><br><span class="line">-16</span><br></pre></td></tr></table></figure>
<p>注：运行多次结果可能都不相同</p>
<p><mark>注：调用<code>detach()</code>后不能再用<code>join()</code>，否则系统报错。</mark></p>
<p><code>joinable()</code>判断是否可以成功使用<code>join()</code>或者<code>detach()</code></p>
<p>如果返回<code>true</code>，证明可以调用<code>join()</code>或者<code>detach()</code></p>
<p>如果返回<code>false</code>，证明调用过<code>join()</code>或者<code>detach()</code>，<code>join()</code>和<code>detach()</code>都不能再调用了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myprint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;This is my thread.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;My thread is finished&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">thread <span class="title">mytobj</span><span class="params">(myprint)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mytobj.<span class="built_in">joinable</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;可以调用可以调用join()或者detach()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;不能调用可以调用join()或者detach()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mytobj.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mytobj.<span class="built_in">joinable</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;可以调用可以调用join()或者detach()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;不能调用可以调用join()或者detach()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;BeiJing welcomes me?&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">可以调用可以调用join()或者detach()</span><br><span class="line">This is my thread.</span><br><span class="line">不能调用可以调用join()或者detach()</span><br><span class="line">BeiJing welcomes me?</span><br><span class="line">My thread is finished</span><br></pre></td></tr></table></figure>
<h2 id="使用类对象创建线程">使用类对象创建线程</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ta</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="comment">//不能带参数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;This is my thread.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;线程中输出 i^2 &quot;</span> &lt;&lt; i * i &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;My thread is finished&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Ta ta;</span><br><span class="line">	<span class="function">thread <span class="title">myThread</span><span class="params">(ta)</span></span>;</span><br><span class="line"></span><br><span class="line">	myThread.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">// 	myThread.detach();</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;BeiJing welcomes me?&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;主线程中输出 -i^2 &quot;</span> &lt;&lt; -i * i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>mytobj.join();</code>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">This is my thread.</span><br><span class="line">线程中输出 i^2 0</span><br><span class="line">线程中输出 i^2 1</span><br><span class="line">线程中输出 i^2 4</span><br><span class="line">线程中输出 i^2 9</span><br><span class="line">线程中输出 i^2 16</span><br><span class="line">My thread is finished</span><br><span class="line">BeiJing welcomes me?</span><br><span class="line">主线程中输出 -i^2 0</span><br><span class="line">主线程中输出 -i^2 -1</span><br><span class="line">主线程中输出 -i^2 -4</span><br><span class="line">主线程中输出 -i^2 -9</span><br><span class="line">主线程中输出 -i^2 -16</span><br></pre></td></tr></table></figure>
<p><code>mytobj.detach();</code>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BeiJing welcomes me?This is my thread.</span><br><span class="line">线程中输出 i*mi 0</span><br><span class="line">线程中输出 i*mi 6</span><br><span class="line">线程中输出 i*mi 12</span><br><span class="line">线程中输出 i*mi 18</span><br><span class="line">线程中输出 i*mi 24</span><br><span class="line">My thread is finished</span><br><span class="line"></span><br><span class="line">主线程中输出 -i^2 0</span><br><span class="line">主线程中输出 -i^2 -1</span><br><span class="line">主线程中输出 -i^2 -4</span><br><span class="line">主线程中输出 -i^2 -9</span><br><span class="line">主线程中输出 -i^2 -16</span><br></pre></td></tr></table></figure>
<p><mark>注：主线程运行结束之后，main()函数中的变量会被销毁，但对象会被复制到线程中去，复制的对象依旧存在</mark></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ta</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span>&amp; mi;</span><br><span class="line">	<span class="built_in">Ta</span>(<span class="type">int</span> &amp;i):<span class="built_in">mi</span>(i)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Ta()构造函数被执行&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Ta</span>(<span class="type">const</span> Ta&amp; ta) :<span class="built_in">mi</span>(ta.mi)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Ta()拷贝构造函数被执行&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Ta</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;~Ta()析构函数被执行&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="comment">//不能带参数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;This is my thread.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;线程中输出 i*mi &quot;</span> &lt;&lt; i * mi &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;My thread is finished&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">6</span>;</span><br><span class="line">	<span class="function">Ta <span class="title">ta</span><span class="params">(i)</span></span>; <span class="comment">// 构造函数被调用</span></span><br><span class="line">	<span class="function">thread <span class="title">myThread</span><span class="params">(ta)</span></span>; <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">	<span class="comment">// myThread 结束后析构，内部拷贝的 Ta 对象析构</span></span><br><span class="line"></span><br><span class="line">	myThread.<span class="built_in">join</span>();	<span class="comment">// 线程对象 `myThread` 在 `join` 完成后析构，析构时内部拷贝的 `Ta` 对象析构</span></span><br><span class="line">    <span class="comment">// myThread.detach();</span></span><br><span class="line">    </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;BeiJing welcomes me?&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;主线程中输出 -i^2 &quot;</span> &lt;&lt; -i * i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">// 主线程结束，局部变量 `ta` 的析构</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>myThread.join()</code>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Ta()构造函数被执行</span><br><span class="line">Ta()拷贝构造函数被执行</span><br><span class="line">Ta()拷贝构造函数被执行</span><br><span class="line">~Ta()析构函数被执行</span><br><span class="line">This is my thread.</span><br><span class="line">线程中输出 i*mi 0</span><br><span class="line">线程中输出 i*mi 6</span><br><span class="line">线程中输出 i*mi 12</span><br><span class="line">线程中输出 i*mi 18</span><br><span class="line">线程中输出 i*mi 24</span><br><span class="line">My thread is finished</span><br><span class="line">~Ta()析构函数被执行</span><br><span class="line">BeiJing welcomes me?</span><br><span class="line">主线程中输出 -i^2 0</span><br><span class="line">主线程中输出 -i^2 -1</span><br><span class="line">主线程中输出 -i^2 -4</span><br><span class="line">主线程中输出 -i^2 -9</span><br><span class="line">主线程中输出 -i^2 -16</span><br><span class="line">~Ta()析构函数被执行</span><br></pre></td></tr></table></figure>
<p><code>myThread.detach()</code>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Ta()构造函数被执行</span><br><span class="line">Ta()拷贝构造函数被执行</span><br><span class="line">Ta()拷贝构造函数被执行</span><br><span class="line">~Ta()析构函数被执行</span><br><span class="line">BeiJing welcomes me?</span><br><span class="line">主线程中输出 -i^2 0</span><br><span class="line">主线程中输出 -i^2 -1</span><br><span class="line">主线程中输出 -i^2 -4</span><br><span class="line">主线程中输出 -i^2 -9</span><br><span class="line">This is my thread.主线程中输出 -i^2 -16</span><br><span class="line"></span><br><span class="line">线程中输出 i*mi 0</span><br><span class="line">线程中输出 i*mi 6</span><br><span class="line">线程中输出 i*mi 12</span><br><span class="line">线程中输出 i*mi 18</span><br><span class="line">线程中输出 i*mi 24</span><br><span class="line">My thread is finished</span><br><span class="line">~Ta()析构函数被执行</span><br><span class="line">~Ta()析构函数被执行</span><br></pre></td></tr></table></figure>
<h2 id="lamda表达式创建线程">lamda表达式创建线程</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> lambdaThread = [] &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;This is my thread.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;线程中输出 i*i &quot;</span> &lt;&lt; i * i &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;My thread is finished&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function">thread <span class="title">myThread</span><span class="params">(lambdaThread)</span></span>;</span><br><span class="line">	myThread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;BeiJing welcomes me?&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;主线程中输出 -i^2 &quot;</span> &lt;&lt; -i * i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">This is my thread.</span><br><span class="line">线程中输出 i*i 0</span><br><span class="line">线程中输出 i*i 1</span><br><span class="line">线程中输出 i*i 4</span><br><span class="line">线程中输出 i*i 9</span><br><span class="line">线程中输出 i*i 16</span><br><span class="line">My thread is finished</span><br><span class="line">BeiJing welcomes me?</span><br><span class="line">主线程中输出 -i^2 0</span><br><span class="line">主线程中输出 -i^2 -1</span><br><span class="line">主线程中输出 -i^2 -4</span><br><span class="line">主线程中输出 -i^2 -9</span><br><span class="line">主线程中输出 -i^2 -16</span><br></pre></td></tr></table></figure>
<h1>传递临时对象</h1>
<h2 id="值传递与指针传递">值传递与指针传递</h2>
<p>当使用 detach() 分离线程时，传递参数应注意以下问题：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>传递 int 等简单类型参数时，建议<strong>使用值传递</strong>，而不使用引用传递，避免参数回收的问题（<strong>主线程首先结束，引用传递的参数被回收了，导致子线程的参数无效</strong>）；</p>
</li>
<li class="lvl-2">
<p>当传递复杂类型参数时（如类等），应避免发生隐式类型转换（发生隐式类型转换时，可能会发生主线程结束了，要传递的参数还没进行隐式类型转换，而此时参数已经被回收了），可通过生成临时对象的方式（例如下面代码中的 std::string(s) 和 class(value)都在主线程中首先生成临时对象，再进行参数传递）来进行参数传递，同时在函数参数内用引用（例如 myprint 函数中 const myclass &amp;cls）进行接收；</p>
</li>
</ul>
<p>非必要情况，应<mark>尽量避免使用 detach() 来分离线程</mark>；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; i, <span class="type">char</span>* pmybuf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 如果线程从主线程detach了</span></span><br><span class="line">	<span class="comment">// i不是mvar真正的引用，实际上值传递，即使主线程运行完毕了，子线程用i仍然是安全的，但仍不推荐传递引用</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;i的地址为：&quot;</span> &lt;&lt; &amp;i &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pmybuf的地址为：&quot;</span> &lt;&lt; &amp;pmybuf &lt;&lt; endl;	<span class="comment">// pmybuf还是指向原来的字符串?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> mvar = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span>&amp; mvary = mvar;	<span class="comment">// 引用</span></span><br><span class="line">	<span class="type">char</span> mybuf[] = <span class="string">&quot;this is a test&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mvar的地址为：&quot;</span> &lt;&lt; &amp;mvar &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mvary的地址为：&quot;</span> &lt;&lt; &amp;mvary &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mybuf的地址为：&quot;</span> &lt;&lt; &amp;mybuf &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">thread <span class="title">myThread</span><span class="params">(myPrint, mvar, mybuf)</span></span>;	<span class="comment">// 第一个参数是函数名，后两个参数是函数的参数</span></span><br><span class="line">	myThread.<span class="built_in">join</span>();</span><br><span class="line">	<span class="comment">// myThread.detach();</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;BeiJing welcomes me?&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mvar的地址为：0x16b4b6914</span><br><span class="line">mvary的地址为：0x16b4b6914</span><br><span class="line">pmybuf的地址为：0x16b4b6918</span><br><span class="line">i的地址为：0x12df040d0</span><br><span class="line">mybuf的地址为：0x16b53ef10</span><br><span class="line">BeiJing welcomes me?</span><br></pre></td></tr></table></figure>
<p>注：<code>i</code>并不是<code>mvar</code>的引用，实际上是<mark>值传递</mark>。</p>
<p>但是指针传递时，在<code>detach()</code>的子线程中，会有main()函数运行完时被销毁的可能。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> string&amp; pmybuf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;i的地址为：&quot;</span> &lt;&lt; &amp;i &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; pmybuf &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pmybuf的地址为：&quot;</span> &lt;&lt; &amp;pmybuf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> mvar = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span>&amp; mvary = mvar;</span><br><span class="line">	<span class="type">char</span> mybuf[] = <span class="string">&quot;this is a test&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mvar的地址为：&quot;</span> &lt;&lt; &amp;mvar &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mvary的地址为：&quot;</span> &lt;&lt; &amp;mvary &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mybuf的地址为：&quot;</span> &lt;&lt; &amp;mybuf &lt;&lt; endl;</span><br><span class="line">	<span class="comment">// 如果detach了，这样仍然是不安全的</span></span><br><span class="line">	<span class="comment">// 因为存在主线程运行完了，mybuf被回收了，系统采用mybuf隐式类型转换成string</span></span><br><span class="line">	<span class="comment">// 推荐先创建一个临时对象thread myThread(myPrint, mvar, string(mybuf));</span></span><br><span class="line">	<span class="function">thread <span class="title">myThread</span><span class="params">(myPrint, mvar, mybuf)</span></span>;</span><br><span class="line">	myThread.<span class="built_in">join</span>();</span><br><span class="line">	<span class="comment">//myThread.detach();</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;BeiJing welcomes me?&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mvar的地址为：0x16f3f2914</span><br><span class="line">mvary的地址为：0x16f3f2914</span><br><span class="line">mybuf的地址为：0x16f3f2918</span><br><span class="line">1</span><br><span class="line">i的地址为：0x16f47aedc</span><br><span class="line">this is a test</span><br><span class="line">pmybuf的地址为：0x16f47af20</span><br><span class="line">BeiJing welcomes me?</span><br></pre></td></tr></table></figure>
<h2 id="传递临时类对象">传递临时类对象</h2>
<p>创建线程同时构造临时对象传递参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建自定义类</span></span><br><span class="line"><span class="comment">// 类型转换构造函数，把int整型转换为myclass类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> m_i;</span><br><span class="line">        <span class="built_in">myclass</span>(<span class="type">int</span> a): <span class="built_in">m_i</span>(a) &#123; cout &lt;&lt; <span class="string">&quot;构造函数myclass::myclass(int a)执行&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl ;&#125; ;</span><br><span class="line">        <span class="built_in">myclass</span>(<span class="type">const</span> myclass &amp;a): <span class="built_in">m_i</span>(a.m_i) &#123; cout &lt;&lt; <span class="string">&quot;拷贝构造函数myclass::myclass(const int a)执行&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl ;&#125; ;</span><br><span class="line">        ~<span class="built_in">myclass</span>() &#123; cout &lt;&lt; <span class="string">&quot;析构函数myclass::~myclass()执行&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl ;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> myclass&amp; pmybuf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;i的地址为：&quot;</span> &lt;&lt; &amp;i &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pmybuf的地址为：&quot;</span> &lt;&lt; &amp;pmybuf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> mvar = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> myvar2 = <span class="number">66</span>;</span><br><span class="line">	<span class="function">thread <span class="title">myThread</span><span class="params">(myPrint, mvar, myclass(myvar2))</span></span>;</span><br><span class="line">	<span class="comment">// myThread.join();</span></span><br><span class="line">	myThread.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;BeiJing welcomes me?&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">构造函数myclass::myclass(int a)执行0x16d3ba91c</span><br><span class="line">拷贝构造函数myclass::myclass(const int a)执行0x158605f14</span><br><span class="line">析构函数myclass::~myclass()执行0x16d3ba91c</span><br><span class="line">BeiJing welcomes me?</span><br><span class="line">1</span><br><span class="line">i的地址为：0x16d442f1c</span><br><span class="line">pmybuf的地址为：0x158605f14</span><br><span class="line">析构函数myclass::~myclass()执行0x158605f14</span><br></pre></td></tr></table></figure>
<h3 id="不使用临时对象传递">不使用临时对象传递</h3>
<p><strong>线程ID</strong> <code>std::this_thread::get_id()</code></p>
<p>在子线程中构造对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建自定义类</span></span><br><span class="line"><span class="comment">// 类型转换构造函数，把int整型转换为myclass类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_i;</span><br><span class="line">	<span class="built_in">myclass</span>(<span class="type">int</span> a): <span class="built_in">m_i</span>(a) &#123; cout &lt;&lt; <span class="string">&quot;构造函数myclass::myclass(int a)执行&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  threadid = &quot;</span>&lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl ;&#125; ;</span><br><span class="line">	<span class="built_in">myclass</span>(<span class="type">const</span> myclass &amp;a): <span class="built_in">m_i</span>(a.m_i) &#123; cout &lt;&lt; <span class="string">&quot;拷贝构造函数myclass::myclass(const int a)执行&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  threadid = &quot;</span>&lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl ;&#125; ;</span><br><span class="line">	~<span class="built_in">myclass</span>() &#123; cout &lt;&lt; <span class="string">&quot;析构函数myclass::~myclass()执行&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  threadid = &quot;</span>&lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl ;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">const</span> myclass&amp; pmybuf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pmybuf的地址为：&quot;</span> &lt;&lt; &amp;pmybuf &lt;&lt; <span class="string">&quot;  子线程id为 &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout&lt;&lt; <span class="string">&quot;主线程id为 &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="type">int</span> myvar = <span class="number">66</span>;</span><br><span class="line">	<span class="function">thread <span class="title">myThread</span><span class="params">(myPrint, myvar)</span></span>;	<span class="comment">// 在子线程中构造对象</span></span><br><span class="line">	myThread.<span class="built_in">join</span>();</span><br><span class="line">	<span class="comment">// myThread.detach();</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;BeiJing welcomes me?&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">主线程id为 0x1e8b9fac0</span><br><span class="line">构造函数myclass::myclass(int a)执行0x16d196f3c  threadid = 0x16d197000</span><br><span class="line">pmybuf的地址为：0x16d196f3c  子线程id为 0x16d197000</span><br><span class="line">析构函数myclass::~myclass()执行0x16d196f3c  threadid = 0x16d197000</span><br><span class="line">BeiJing welcomes me?</span><br></pre></td></tr></table></figure>
<p>子线程需要使用主线程的变量 value 来进行构造和析构操作（具体可见构造和析构发生的线程 id 与主线程 id 不同）</p>
<p>当使用 detach 分离两个线程时，可能会出现主线程执行完毕了，主线程的变量 value 已被回收，而子线程来不及拷贝 value 变量来进行类的构造和析构操作；</p>
<h3 id="使用临时对象传递">使用临时对象传递</h3>
<p>在主线程中构造对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建自定义类</span></span><br><span class="line"><span class="comment">// 类型转换构造函数，把int整型转换为myclass类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_i;</span><br><span class="line">	<span class="built_in">myclass</span>(<span class="type">int</span> a): <span class="built_in">m_i</span>(a) &#123; cout &lt;&lt; <span class="string">&quot;构造函数myclass::myclass(int a)执行&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  threadid = &quot;</span>&lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl ;&#125; ;</span><br><span class="line">	<span class="built_in">myclass</span>(<span class="type">const</span> myclass &amp;a): <span class="built_in">m_i</span>(a.m_i) &#123; cout &lt;&lt; <span class="string">&quot;拷贝构造函数myclass::myclass(const int a)执行&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  threadid = &quot;</span>&lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl ;&#125; ;</span><br><span class="line">	~<span class="built_in">myclass</span>() &#123; cout &lt;&lt; <span class="string">&quot;析构函数myclass::~myclass()执行&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  threadid = &quot;</span>&lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl ;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">const</span> myclass&amp; pmybuf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pmybuf的地址为：&quot;</span> &lt;&lt; &amp;pmybuf &lt;&lt; <span class="string">&quot;  子线程id为 &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout&lt;&lt; <span class="string">&quot;主线程id为 &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="type">int</span> myvar = <span class="number">66</span>;</span><br><span class="line">	<span class="function">thread <span class="title">myThread</span><span class="params">(myPrint, myclass(myvar))</span></span>;	<span class="comment">// 所有的对象构建都在main函数中构建完毕</span></span><br><span class="line">	myThread.<span class="built_in">join</span>();</span><br><span class="line">	<span class="comment">// myThread.detach();</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;BeiJing welcomes me?&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">主线程id为 0x1e8b9fac0</span><br><span class="line">构造函数myclass::myclass(int a)执行0x16b872914  threadid = 0x1e8b9fac0</span><br><span class="line">拷贝构造函数myclass::myclass(const int a)执行0x127e05f10  threadid = 0x1e8b9fac0</span><br><span class="line">析构函数myclass::~myclass()执行0x16b872914  threadid = 0x1e8b9fac0</span><br><span class="line">pmybuf的地址为：0x127e05f10  子线程id为 0x16b8fb000</span><br><span class="line">析构函数myclass::~myclass()执行0x127e05f10  threadid = 0x16b8fb000</span><br><span class="line">BeiJing welcomes me?</span><br></pre></td></tr></table></figure>
<p>临时对象的构造和析构发生在主线程中，即使说主线程的变量value被回收，子线程已经拷贝了value的变量，不会因为主线程的结束而出问题</p>
<h3 id="修改临时对象内参数">修改临时对象内参数</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建自定义类</span></span><br><span class="line"><span class="comment">// 类型转换构造函数，把int整型转换为myclass类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">int</span> m_i;</span><br><span class="line">	<span class="built_in">myclass</span>(<span class="type">int</span> a): <span class="built_in">m_i</span>(a) &#123; cout &lt;&lt; <span class="string">&quot;构造函数myclass::myclass(int a)执行&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  threadid = &quot;</span>&lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl ;&#125; ;</span><br><span class="line">	<span class="built_in">myclass</span>(<span class="type">const</span> myclass &amp;a): <span class="built_in">m_i</span>(a.m_i) &#123; cout &lt;&lt; <span class="string">&quot;拷贝构造函数myclass::myclass(const int a)执行&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  threadid = &quot;</span>&lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl ;&#125; ;</span><br><span class="line">	~<span class="built_in">myclass</span>() &#123; cout &lt;&lt; <span class="string">&quot;析构函数myclass::~myclass()执行&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  threadid = &quot;</span>&lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl ;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">const</span> myclass&amp; pmybuf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pmybuf.m_i = <span class="number">2333</span>; <span class="comment">// 修改类中的值</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pmybuf的地址为：&quot;</span> &lt;&lt; &amp;pmybuf &lt;&lt; <span class="string">&quot;  pmybuf的值为：&quot;</span> &lt;&lt; pmybuf.m_i &lt;&lt; <span class="string">&quot;  子线程id为 &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout&lt;&lt; <span class="string">&quot;主线程id为 &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="function">myclass <span class="title">A</span><span class="params">(<span class="number">666</span>)</span></span>;</span><br><span class="line">	cout&lt;&lt; <span class="string">&quot;类A的地址&quot;</span> &lt;&lt; &amp;A &lt;&lt; <span class="string">&quot;  类A的值&quot;</span> &lt;&lt; A.m_i &lt;&lt; endl;</span><br><span class="line">    <span class="function">thread <span class="title">myThread</span><span class="params">(myPrint, A)</span></span>;</span><br><span class="line">	myThread.<span class="built_in">join</span>();</span><br><span class="line">	<span class="comment">// myThread.detach();</span></span><br><span class="line"></span><br><span class="line">	cout&lt;&lt; <span class="string">&quot;类A的值&quot;</span> &lt;&lt; A.m_i &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;BeiJing welcomes me?&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">主线程id为 0x1e8b9fac0</span><br><span class="line">构造函数myclass::myclass(int a)执行0x16cf16924  threadid = 0x1e8b9fac0</span><br><span class="line">类A的地址0x16cf16924  类A的值666</span><br><span class="line">拷贝构造函数myclass::myclass(const int a)执行0x144e05f10  threadid = 0x1e8b9fac0</span><br><span class="line">pmybuf的地址为：0x144e05f10  pmybuf的值为：2333  子线程id为 0x16cf9f000</span><br><span class="line">析构函数myclass::~myclass()执行0x144e05f10  threadid = 0x16cf9f000</span><br><span class="line">类A的值666</span><br><span class="line">BeiJing welcomes me?</span><br></pre></td></tr></table></figure>
<p>并没有修改main函数中类的值，只修改了拷贝的类中的值</p>
<p><code>std::ref</code>函数能将地址传输</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建自定义类</span></span><br><span class="line"><span class="comment">// 类型转换构造函数，把int整型转换为myclass类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_i;</span><br><span class="line">	<span class="built_in">myclass</span>(<span class="type">int</span> a): <span class="built_in">m_i</span>(a) &#123; cout &lt;&lt; <span class="string">&quot;构造函数myclass::myclass(int a)执行&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  threadid = &quot;</span>&lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl ;&#125; ;</span><br><span class="line">	<span class="built_in">myclass</span>(<span class="type">const</span> myclass &amp;a): <span class="built_in">m_i</span>(a.m_i) &#123; cout &lt;&lt; <span class="string">&quot;拷贝构造函数myclass::myclass(const int a)执行&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  threadid = &quot;</span>&lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl ;&#125; ;</span><br><span class="line">	~<span class="built_in">myclass</span>() &#123; cout &lt;&lt; <span class="string">&quot;析构函数myclass::~myclass()执行&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  threadid = &quot;</span>&lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl ;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(myclass&amp; pmybuf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pmybuf.m_i = <span class="number">2333</span>; <span class="comment">// 修改类中的值</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pmybuf的地址为：&quot;</span> &lt;&lt; &amp;pmybuf &lt;&lt; <span class="string">&quot;  pmybuf的值为：&quot;</span> &lt;&lt; pmybuf.m_i &lt;&lt; <span class="string">&quot;  子线程id为 &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout&lt;&lt; <span class="string">&quot;主线程id为 &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="function">myclass <span class="title">A</span><span class="params">(<span class="number">666</span>)</span></span>;</span><br><span class="line">	cout&lt;&lt; <span class="string">&quot;类A的地址&quot;</span> &lt;&lt; &amp;A &lt;&lt; <span class="string">&quot;  类A的值&quot;</span> &lt;&lt; A.m_i &lt;&lt; endl;</span><br><span class="line">	<span class="function">thread <span class="title">myThread</span><span class="params">(myPrint, std::ref(A))</span></span>;</span><br><span class="line">	myThread.<span class="built_in">join</span>();</span><br><span class="line">	<span class="comment">// myThread.detach();</span></span><br><span class="line"></span><br><span class="line">	cout&lt;&lt; <span class="string">&quot;类A的值&quot;</span> &lt;&lt; A.m_i &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;BeiJing welcomes me?&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">主线程id为 0x1e8b9fac0</span><br><span class="line">构造函数myclass::myclass(int a)执行0x16dbfa924  threadid = 0x1e8b9fac0</span><br><span class="line">类A的地址0x16dbfa924  类A的值666</span><br><span class="line">pmybuf的地址为：0x16dbfa924  pmybuf的值为：2333  子线程id为 0x16dc83000</span><br><span class="line">类A的值2333</span><br><span class="line">BeiJing welcomes me?</span><br><span class="line">析构函数myclass::~myclass()执行0x16dbfa924  threadid = 0x1e8b9fac0</span><br></pre></td></tr></table></figure>
<p>修改了类中的值</p>
<h2 id="智能指针传递临时对象">智能指针传递临时对象</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(unique_ptr&lt;<span class="type">int</span>&gt; ptn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout&lt;&lt; <span class="string">&quot;子线程中的指针地址为&quot;</span> &lt;&lt; ptn &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;thread_id = &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">up</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">	<span class="comment">// 独占式指针只能通过std::move()才可以传递给另一个指针</span></span><br><span class="line">	<span class="comment">// 传递后up就指向空，新的ptn指向原来的内存</span></span><br><span class="line">	cout&lt;&lt; <span class="string">&quot;主线程中的指针地址为&quot;</span> &lt;&lt; up &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;thread_id = &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="function">thread <span class="title">myThread</span><span class="params">(myPrint, std::move(up))</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 所以这时就不能用detach了，因为如果主线程先执行完，ptn指向的对象就被释放了</span></span><br><span class="line">	myThread.<span class="built_in">join</span>();</span><br><span class="line">	<span class="comment">// myThread.detach();</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主线程中的指针地址为0x142e05fa0</span><br><span class="line">thread_id = 0x1e8b9fac0</span><br><span class="line">子线程中的指针地址为0x142e05fa0</span><br><span class="line">thread_id = 0x16b70f000</span><br></pre></td></tr></table></figure>
<h2 id="成员函数指针">成员函数指针</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_i;</span><br><span class="line">	<span class="built_in">myclass</span>(<span class="type">int</span> a): <span class="built_in">m_i</span>(a) &#123; cout &lt;&lt; <span class="string">&quot;构造函数myclass::myclass(int a)执行&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  threadid = &quot;</span>&lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl ;&#125; ;</span><br><span class="line">	<span class="built_in">myclass</span>(<span class="type">const</span> myclass &amp;a): <span class="built_in">m_i</span>(a.m_i) &#123; cout &lt;&lt; <span class="string">&quot;拷贝构造函数myclass::myclass(const int a)执行&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  threadid = &quot;</span>&lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl ;&#125; ;</span><br><span class="line">	~<span class="built_in">myclass</span>() &#123; cout &lt;&lt; <span class="string">&quot;析构函数myclass::~myclass()执行&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  threadid = &quot;</span>&lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl ;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//线程的执行入口</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">thread_work</span><span class="params">(<span class="type">int</span> num)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;[子线程 thread_work 执行]&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  threadid = &quot;</span>&lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">myclass <span class="title">myobj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="comment">// 第一个为线程的入口函数，第二个为类对象，第三个为函数的参数</span></span><br><span class="line">	<span class="function">thread <span class="title">mytobj</span><span class="params">(&amp;myclass::thread_work, myobj, <span class="number">15</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果传ref指针，则用的就是myobj本身，此时用 detach() 则错了</span></span><br><span class="line">	<span class="comment">// std::thread mytobj(&amp;A::thread_work, std::ref(myobj), 15);</span></span><br><span class="line"></span><br><span class="line">	mytobj.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>thread mytobj(&amp;myclass::thread_work, myobj, 15);</code>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">构造函数myclass::myclass(int a)执行0x16ba22928  threadid = 0x1e8b9fac0</span><br><span class="line">拷贝构造函数myclass::myclass(const int a)执行0x15b8040d8  threadid = 0x1e8b9fac0</span><br><span class="line">[子线程 thread_work 执行]0x15b8040d8  threadid = 0x16baab000</span><br><span class="line">析构函数myclass::~myclass()执行0x15b8040d8  threadid = 0x16baab000</span><br><span class="line">析构函数myclass::~myclass()执行0x16ba22928  threadid = 0x1e8b9fac0</span><br></pre></td></tr></table></figure>
<p><code>std::thread mytobj(&amp;A::thread_work, std::ref(myobj), 15);</code>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">构造函数myclass::myclass(int a)执行0x16fc2a928  threadid = 0x1e8b9fac0</span><br><span class="line">[子线程 thread_work 执行]0x16fc2a928  threadid = 0x16fcb3000</span><br><span class="line">析构函数myclass::~myclass()执行0x16fc2a928  threadid = 0x1e8b9fac0</span><br></pre></td></tr></table></figure>
<p>发现<code>std::ref</code>没有调用拷贝构造函数</p>
<h3 id="调用运算符重载">调用运算符重载</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_i;</span><br><span class="line">	<span class="built_in">myclass</span>(<span class="type">int</span> a): <span class="built_in">m_i</span>(a) &#123; cout &lt;&lt; <span class="string">&quot;构造函数myclass::myclass(int a)执行&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  threadid = &quot;</span>&lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl ;&#125; ;</span><br><span class="line">	<span class="built_in">myclass</span>(<span class="type">const</span> myclass &amp;a): <span class="built_in">m_i</span>(a.m_i) &#123; cout &lt;&lt; <span class="string">&quot;拷贝构造函数myclass::myclass(const int a)执行&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  threadid = &quot;</span>&lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl ;&#125; ;</span><br><span class="line">	~<span class="built_in">myclass</span>() &#123; cout &lt;&lt; <span class="string">&quot;析构函数myclass::~myclass()执行&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  threadid = &quot;</span>&lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl ;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//线程的执行入口</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">thread_work</span><span class="params">(<span class="type">int</span> num)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;[子线程 thread_work 执行]&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  threadid = &quot;</span>&lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;[子线程()执行]&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  threadid = &quot;</span>&lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">myclass <span class="title">myobj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">mytobj</span><span class="params">(myobj, <span class="number">15</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// thread mytobj(std::ref(myobj), 15);</span></span><br><span class="line"></span><br><span class="line">	mytobj.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>thread mytobj(myobj, 15);</code>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">构造函数myclass::myclass(int a)执行0x16b03e928  threadid = 0x1e8b9fac0</span><br><span class="line">拷贝构造函数myclass::myclass(const int a)执行0x14fe05e38  threadid = 0x1e8b9fac0</span><br><span class="line">[子线程()执行]0x14fe05e38  threadid = 0x16b0c7000</span><br><span class="line">析构函数myclass::~myclass()执行0x14fe05e38  threadid = 0x16b0c7000</span><br><span class="line">析构函数myclass::~myclass()执行0x16b03e928  threadid = 0x1e8b9fac0</span><br></pre></td></tr></table></figure>
<p><code>thread mytobj(std::ref(myobj), 15);</code>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">构造函数myclass::myclass(int a)执行0x16d85e928  threadid = 0x1e8b9fac0</span><br><span class="line">[子线程()执行]0x16d85e928  threadid = 0x16d8e7000</span><br><span class="line">析构函数myclass::~myclass()执行0x16d85e928  threadid = 0x1e8b9fac0</span><br></pre></td></tr></table></figure>
<h1>创建多个线程</h1>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程入口函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myprint</span><span class="params">(<span class="type">int</span> inum)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;myprint线程开始执行了，线程编号 = &quot;</span> &lt;&lt; inum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;thread_id = &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl ;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;myprint线程执行结束了，线程编号 = &quot;</span> &lt;&lt; inum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;thread&gt; mythreads;</span><br><span class="line">	<span class="comment">//创建5个线程，线程入口函数统一使用 myprint</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//创建5个线程，同时这5个线程已经开始执行</span></span><br><span class="line">		<span class="comment">//多个线程执行顺序是乱的，和操作系统内部对线程的运行调度机制有关</span></span><br><span class="line">		<span class="comment">//主线程等待所有子线程运行结束，最后主线程结束，推荐join的写法，更容易写出稳定的代码</span></span><br><span class="line">		mythreads.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(myprint, i));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//把thread对象放入容器中进行管理，比较方便</span></span><br><span class="line">	<span class="comment">//使用迭代器取出每一个线程</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> iter = mythreads.<span class="built_in">begin</span>(); iter != mythreads.<span class="built_in">end</span>(); ++iter) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//等待10个线程都返回</span></span><br><span class="line">		iter-&gt;<span class="built_in">join</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;BeiJing welcomes me?&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">myprint线程开始执行了，线程编号 = myprint线程开始执行了，线程编号 = 02</span><br><span class="line">thread_id = 0x16d193000</span><br><span class="line">myprint线程执行结束了，线程编号 = 0</span><br><span class="line"></span><br><span class="line">thread_id = 0x16d2ab000</span><br><span class="line">myprint线程执行结束了，线程编号 = myprint线程开始执行了，线程编号 = 21</span><br><span class="line">myprint线程开始执行了，线程编号 = 3</span><br><span class="line">thread_id = </span><br><span class="line">myprint线程开始执行了，线程编号 = 0x16d337000</span><br><span class="line">4thread_id = myprint线程执行结束了，线程编号 = 30x16d21f000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myprint线程执行结束了，线程编号 = 1thread_id = </span><br><span class="line">0x16d3c3000</span><br><span class="line">myprint线程执行结束了，线程编号 = 4</span><br><span class="line">BeiJing welcomes me?</span><br></pre></td></tr></table></figure>
<h1>数据共享问题</h1>
<h2 id="只读数据">只读数据</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e_v = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;; <span class="comment">// 共享数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程入口函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myprint</span><span class="params">(<span class="type">int</span> inum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;id 为&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;的线程 打印 g_v 的值&quot;</span> &lt;&lt; e_v[<span class="number">0</span>] &lt;&lt; e_v[<span class="number">1</span>] &lt;&lt; e_v[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;thread&gt; mythreads;</span><br><span class="line">	<span class="comment">//创建5个线程，线程入口函数统一使用 myprint</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		mythreads.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(myprint, i));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> iter = mythreads.<span class="built_in">begin</span>(); iter != mythreads.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">	&#123;</span><br><span class="line">		iter-&gt;<span class="built_in">join</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;BeiJing welcomes me?&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id 为id 为0x16f50b000的线程 打印 g_v 的值id 为0x16f623000的线程 打印 g_v 的值112233</span><br><span class="line">id 为0x16f73b000的线程 打印 g_v 的值123</span><br><span class="line"></span><br><span class="line">id 为0x16f6af000的线程 打印 g_v 的值123</span><br><span class="line">0x16f597000的线程 打印 g_v 的值123</span><br><span class="line">BeiJing welcomes me?</span><br></pre></td></tr></table></figure>
<h2 id="独占互斥量">独占互斥量</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>互斥量是一个类对象，理解成一把锁，多个线程尝试用<code>lock()</code>成员函数来尝试加锁头，只有一个线程能够锁定成功，成功的标志是返回，如果没有所成功，那么这个线程的执行流程就会卡在<code>lock()</code>这里不断尝试去锁这把锁；</p>
</li>
<li class="lvl-2">
<p>互斥量使用需要小心：只保护需要保护的数据，也必须保护全（保护多了影响效率，保护少了达不到保护效果），操作完以后要把锁解开，其他线程才能使用lock继续执行；</p>
</li>
</ul>
<p>实际例子：网络游戏服务器有两个自己创建的线程一个线程：收集玩家发来的命令（简化问题：用一个数字代表）,将命令数据写入一个队列一个线程：从队列中取出玩家发送来的命令，解析，执行玩家要干的动作</p>
<h3 id="lock-，unlock">lock()，unlock()</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>步骤：先<code>lock()</code>，操作共享数据，再<code>unlock()</code></p>
</li>
<li class="lvl-2">
<p><code>lock()</code>和<code>unlock()</code>要成对使用，每调用一次<code>lock()</code>，必须调用一次<code>unlock()</code></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员函数作为线程函数的方法来写线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 线程一：从玩家收到的消息入到一个队列的线程</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">inMsgRecvQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;inMsgRecvQueue()执行，插入一个元素&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">                my_mutex.<span class="built_in">lock</span>();	<span class="comment">// 上锁</span></span><br><span class="line">                msgRecvQueue.<span class="built_in">push_back</span>(i);</span><br><span class="line">                my_mutex.<span class="built_in">unlock</span>();	<span class="comment">// 解锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">outMsgLULProc</span><span class="params">(<span class="type">int</span> &amp;command)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            my_mutex.<span class="built_in">lock</span>();	<span class="comment">// 上锁</span></span><br><span class="line">            <span class="keyword">if</span> (!msgRecvQueue.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> command = msgRecvQueue.<span class="built_in">front</span>();</span><br><span class="line">                msgRecvQueue.<span class="built_in">pop_front</span>();</span><br><span class="line">                my_mutex.<span class="built_in">unlock</span>();	<span class="comment">// 解锁</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            my_mutex.<span class="built_in">unlock</span>();	<span class="comment">// 解锁</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 线程二：把数据从消息队列取出的线程</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">outMsgRecvQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="type">int</span> command = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">bool</span> result = <span class="built_in">outMsgLULProc</span>(command);</span><br><span class="line">                <span class="keyword">if</span> (result == <span class="literal">true</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;outMsgRecvQueue()执行，释放一个元素&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;outMsgRecvQueue()执行，队列为空！&quot;</span> &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        list&lt;<span class="type">int</span>&gt; msgRecvQueue;	<span class="comment">// 队列：专用于代表玩家发送过来的命令</span></span><br><span class="line">        std::mutex my_mutex; <span class="comment">// 创建一个互斥量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A myobja;</span><br><span class="line">	<span class="comment">// 第二个参数时引用，才能保证线程里，用的时同一个对象</span></span><br><span class="line">	<span class="function">thread <span class="title">myOutMsgobj</span><span class="params">(&amp;A::outMsgRecvQueue, &amp;myobja)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">myInMsgobj</span><span class="params">(&amp;A::inMsgRecvQueue, &amp;myobja)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 操作的时候用代码把共享数据锁住，其他想操作共享数据的线程必须等待</span></span><br><span class="line">	<span class="comment">// 锁住后操作数据、解锁</span></span><br><span class="line">	<span class="comment">// 解锁后其他数据锁住，操作数据、解锁</span></span><br><span class="line">	myOutMsgobj.<span class="built_in">join</span>();</span><br><span class="line">	myInMsgobj.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="std-lock-guard类模板">std::lock_guard类模板</h3>
<p>std::lock_guard类模板：直接取代lock()和unlock();也就是说，<mark>使用了lock_guard()后就不能再使用lock()和unlock()</mark></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inMsgRecvQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;inMsgRecvQueue()执行，插入一个元素&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        <span class="function">td::lock_guard&lt;std::mutex&gt; <span class="title">sbguard</span><span class="params">(my_mutex)</span></span>;</span><br><span class="line">        msgRecvQueue.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">outMsgLULProc</span><span class="params">(<span class="type">int</span> &amp;command)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">sbguard</span><span class="params">(my_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!msgRecvQueue.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> command = msgRecvQueue.<span class="built_in">front</span>();</span><br><span class="line">        msgRecvQueue.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="死锁">死锁</h3>
<p>c++中的死锁（至少有两把锁）：比如有两把锁，锁一，锁二，两个线程，线程A，线程B；（业务：需要把两把锁都锁上）</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>线程A执行的时候，这个线程先锁锁一；然后去锁锁二；</p>
</li>
<li class="lvl-2">
<p>出现了上下文切换，线程A被切换走了，线程B开始执行，这个线程先锁锁二成功；然后线程B去锁锁一；</p>
</li>
</ul>
<p>此时此刻，死锁就发生了</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>线程A锁不了锁二，流程走不下去，所以锁一解不开；</p>
</li>
<li class="lvl-2">
<p>线程B锁不了锁一，流程走不下去，所以锁二解不开；</p>
</li>
</ul>
<h4 id="错误示范">错误示范</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数作为线程函数的方法来写线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">//线程一：从玩家收到的消息入到一个队列的线程</span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">inMsgRecvQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i)</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;inMsgRecvQueue()执行，插入一个元素&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">				<span class="comment">//先锁一，后锁二</span></span><br><span class="line">				my_mutex1.<span class="built_in">lock</span>();</span><br><span class="line">				<span class="comment">//执行.......</span></span><br><span class="line">				my_mutex2.<span class="built_in">lock</span>();</span><br><span class="line">				msgRecvQueue.<span class="built_in">push_back</span>(i);</span><br><span class="line">				<span class="comment">//unlock的顺序无所谓</span></span><br><span class="line">				my_mutex2.<span class="built_in">unlock</span>();</span><br><span class="line">				my_mutex1.<span class="built_in">unlock</span>();</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">outMsgLULProc</span><span class="params">(<span class="type">int</span>&amp; command)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="comment">//先锁二，后锁一</span></span><br><span class="line">			my_mutex2.<span class="built_in">lock</span>();</span><br><span class="line">			<span class="comment">//执行.......</span></span><br><span class="line">			my_mutex1.<span class="built_in">lock</span>();</span><br><span class="line">			<span class="keyword">if</span> (!msgRecvQueue.<span class="built_in">empty</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> command = msgRecvQueue.<span class="built_in">front</span>();</span><br><span class="line">				msgRecvQueue.<span class="built_in">pop_front</span>();</span><br><span class="line">				<span class="comment">//unlock的顺序无所谓</span></span><br><span class="line">				my_mutex1.<span class="built_in">unlock</span>();</span><br><span class="line">				my_mutex2.<span class="built_in">unlock</span>();</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//unlock的顺序无所谓</span></span><br><span class="line">			my_mutex1.<span class="built_in">unlock</span>();</span><br><span class="line">			my_mutex2.<span class="built_in">unlock</span>();</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//线程二：把数据从消息队列取出的线程</span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">outMsgRecvQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="type">int</span> command = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">bool</span> result = <span class="built_in">outMsgLULProc</span>(command);</span><br><span class="line">				<span class="keyword">if</span> (result == <span class="literal">true</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					cout &lt;&lt; <span class="string">&quot;outMsgRecvQueue()执行，释放一个元素&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					cout &lt;&lt; <span class="string">&quot;outMsgRecvQueue()执行，队列为空！&quot;</span> &lt;&lt; endl;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		list&lt;<span class="type">int</span>&gt; msgRecvQueue;</span><br><span class="line">		std::mutex my_mutex1; <span class="comment">//创建第一个互斥量</span></span><br><span class="line">		std::mutex my_mutex2; <span class="comment">//创建第二个互斥量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A myobja;</span><br><span class="line">	</span><br><span class="line">	<span class="function">thread <span class="title">myOutMsgobj</span><span class="params">(&amp;A::outMsgRecvQueue, &amp;myobja)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">myInMsgobj</span><span class="params">(&amp;A::inMsgRecvQueue, &amp;myobja)</span></span>;</span><br><span class="line"></span><br><span class="line">	myOutMsgobj.<span class="built_in">join</span>();</span><br><span class="line">	myInMsgobj.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="互斥量的lock-顺序一致">互斥量的lock()顺序一致</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inMsgRecvQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;inMsgRecvQueue()执行，插入一个元素&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//先锁一，后锁二</span></span><br><span class="line">		my_mutex1.<span class="built_in">lock</span>();</span><br><span class="line">		<span class="comment">//执行.......</span></span><br><span class="line">		my_mutex2.<span class="built_in">lock</span>();</span><br><span class="line">		msgRecvQueue.<span class="built_in">push_back</span>(i);</span><br><span class="line">		<span class="comment">//unlock的顺序无所谓</span></span><br><span class="line">		my_mutex2.<span class="built_in">unlock</span>();</span><br><span class="line">		my_mutex1.<span class="built_in">unlock</span>();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">outMsgLULProc</span><span class="params">(<span class="type">int</span>&amp; command)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//先锁一，后锁二</span></span><br><span class="line">	my_mutex1.<span class="built_in">lock</span>();</span><br><span class="line">	<span class="comment">//执行.......</span></span><br><span class="line">	my_mutex2.<span class="built_in">lock</span>();</span><br><span class="line">	<span class="keyword">if</span> (!msgRecvQueue.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> command = msgRecvQueue.<span class="built_in">front</span>();</span><br><span class="line">		msgRecvQueue.<span class="built_in">pop_front</span>();</span><br><span class="line">		<span class="comment">//unlock的顺序无所谓</span></span><br><span class="line">		my_mutex2.<span class="built_in">unlock</span>();</span><br><span class="line">		my_mutex1.<span class="built_in">unlock</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//unlock的顺序无所谓</span></span><br><span class="line">	my_mutex2.<span class="built_in">unlock</span>();</span><br><span class="line">	my_mutex1.<span class="built_in">unlock</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="std-lock-函数模板">std::lock()函数模板</h4>
<p><code>std::lock()</code>用于处理多个互斥量；一次锁住两个或者两个以上的互斥量（至少两个）；（同时锁住多个互斥量的情况比较少见）；</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>不存在在多线程中，因为锁的顺序导致死锁的风险问题；</p>
</li>
<li class="lvl-2">
<p>std::lock()：如果互斥量中有一个每锁住，他就会释放自己锁住的，然后就等在那里，等所有互斥量都锁住，才往下走；</p>
</li>
<li class="lvl-2">
<p>要么两个互斥量都锁住或者两个互斥量都释放；如果只锁一个，另外一个没成功，则立即释放锁住的；</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inMsgRecvQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;inMsgRecvQueue()执行，插入一个元素&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">		std::<span class="built_in">lock</span>(my_mutex1, my_mutex2);</span><br><span class="line">		msgRecvQueue.<span class="built_in">push_back</span>(i);</span><br><span class="line">		<span class="comment">//unlock的顺序无所谓</span></span><br><span class="line">		my_mutex2.<span class="built_in">unlock</span>();</span><br><span class="line">		my_mutex1.<span class="built_in">unlock</span>();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">outMsgLULProc</span><span class="params">(<span class="type">int</span>&amp; command)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::<span class="built_in">lock</span>(my_mutex1, my_mutex2);</span><br><span class="line">	<span class="keyword">if</span> (!msgRecvQueue.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> command = msgRecvQueue.<span class="built_in">front</span>();</span><br><span class="line">		msgRecvQueue.<span class="built_in">pop_front</span>();</span><br><span class="line">		<span class="comment">//unlock的顺序无所谓</span></span><br><span class="line">		my_mutex2.<span class="built_in">unlock</span>();</span><br><span class="line">		my_mutex1.<span class="built_in">unlock</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//unlock的顺序无所谓</span></span><br><span class="line">	my_mutex2.<span class="built_in">unlock</span>();</span><br><span class="line">	my_mutex1.<span class="built_in">unlock</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="std-lock-guard的std-adopt-lock参数">std::lock_guard的std::adopt_lock参数</h4>
<p><code>std::adopt_lock</code>是一个结构体对象，起一个标记作用，表示互斥量已经进行lock了，不需要在构造函数里面在对其进行lock；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inMsgRecvQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;inMsgRecvQueue()执行，插入一个元素&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">		std::<span class="built_in">lock</span>(my_mutex1, my_mutex2);</span><br><span class="line">		<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">sbguard1</span><span class="params">(my_mutex1, std::adopt_lock)</span></span>;</span><br><span class="line">		<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">sbguard2</span><span class="params">(my_mutex2, std::adopt_lock)</span></span>;</span><br><span class="line">		msgRecvQueue.<span class="built_in">push_back</span>(i);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">outMsgLULProc</span><span class="params">(<span class="type">int</span>&amp; command)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::<span class="built_in">lock</span>(my_mutex1, my_mutex2);</span><br><span class="line">	<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">sbguard1</span><span class="params">(my_mutex1, std::adopt_lock)</span></span>;</span><br><span class="line">	<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">sbguard2</span><span class="params">(my_mutex2, std::adopt_lock)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (!msgRecvQueue.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> command = msgRecvQueue.<span class="built_in">front</span>();</span><br><span class="line">		msgRecvQueue.<span class="built_in">pop_front</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="unique-lock-类模板">unique_lock()类模板</h3>
<p>unique_lock比lock_guard灵活很多（多出来很多用法），效率差一点</p>
<h4 id="取代lock-guard">取代lock_guard()</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inMsgRecvQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;inMsgRecvQueue()执行，插入一个元素&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// std::lock_guard&lt;std::mutex&gt; sbguard(my_mutex);</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">myUniLock</span><span class="params">(my_mutex)</span></span>;</span><br><span class="line">        msgRecvQueue.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="参数">参数</h4>
<ol>
<li class="lvl-3">
<p><strong>std::adopt_lock</strong></p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>表示这个互斥量已经被lock()，即不需要在构造函数中lock这个互斥量了。</p>
</li>
<li class="lvl-2">
<p>前提：必须提前lock</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inMsgRecvQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;inMsgRecvQueue()执行，插入一个元素&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        my_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">myUniLock</span><span class="params">(my_mutex, std::adopt_lock)</span></span>;</span><br><span class="line">        msgRecvQueue.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p><strong>std::try_to_lock</strong></p>
</li>
</ol>
<p>尝试用mutex的lock()去锁定这个mutex，但如果没有锁定成功，会立即返回，不会阻塞在那里；使用try_to_lock的原因是防止其他的线程锁定mutex太长时间，导致本线程一直阻塞在lock这个地方前提：不能提前lock();
owns_lock()方法判断是否拿到锁，如拿到返回true</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;inMsgRecvQueue()执行&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">myUniLock</span><span class="params">(my_mutex, std::try_to_lock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (sbguard.<span class="built_in">owns_lock</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;拿到了锁，执行命令，插入一个元素&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        msgRecvQueue.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;inMsgRecvQueue()执行但没有拿到锁，执行其他命令&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p><strong>std::defer_lock：</strong></p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果没有第二个参数就对mutex进行加锁，加上defer_lock是<mark>始化了一个没有加锁的mutex</mark></p>
</li>
<li class="lvl-2">
<p>不给它加锁的目的是以后可以调用unique_lock的一些方法</p>
</li>
<li class="lvl-2">
<p>前提：不能提前lock</p>
</li>
</ul>
<h4 id="成员函数">成员函数</h4>
<p><strong>lock()：加锁</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">myUniLock</span><span class="params">(myMutex， defer_lock)</span></span>;</span><br><span class="line">myUniLock.<span class="built_in">lock</span>();</span><br></pre></td></tr></table></figure>
<p>不用自己unlock();</p>
<p><strong>unlock()：解锁</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">myUniLock</span><span class="params">(myMutex， defer_lock)</span></span>;</span><br><span class="line">myUniLock.<span class="built_in">lock</span>();</span><br><span class="line"><span class="comment">//处理一些共享代码</span></span><br><span class="line">myUniLock.<span class="built_in">unlock</span>();</span><br><span class="line"><span class="comment">//处理一些非共享代码</span></span><br><span class="line">myUniLock.<span class="built_in">lock</span>();</span><br><span class="line"><span class="comment">//处理一些共享代码</span></span><br></pre></td></tr></table></figure>
<p>因为一些非共享代码要处理，可以暂时先unlock()，用其他线程把它们处理了，处理完后再lock()</p>
<p><strong>try_lock()</strong></p>
<p>与<code>std::try_to_lock</code>用法类似</p>
<p><strong>release()：</strong></p>
<p><code>unique_lock&lt;mutex&gt; myUniLock(my_mutex);</code>相当于把myMutex和myUniLock绑定在了一起，release()就是解除绑定，返回它所管理的mutex对象的指针，并释放所有权</p>
<p>所有权由ptx接管，如果原来mutex对象处理加锁状态，就需要ptx在以后进行解锁了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inMsgRecvQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;inMsgRecvQueue()执行&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">myUniLock</span><span class="params">(my_mutex)</span></span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;my_mutex的地址为&quot;</span> &lt;&lt; &amp;my_mutex &lt;&lt; endl;</span><br><span class="line">        mutex* ptx = myUniLock.<span class="built_in">release</span>();</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;ptx的地址为&quot;</span> &lt;&lt; ptx &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        msgRecvQueue.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">        ptx-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lock的代码段越少，执行越快，整个程序的运行效率越高。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>锁住的代码少，叫做粒度细，执行效率高；</p>
</li>
<li class="lvl-2">
<p>锁住的代码多，叫做粒度粗，执行效率低；</p>
</li>
</ul>
<h4 id="所有权的传递">所有权的传递</h4>
<p><code>unique_lock&lt;mutex&gt; myUniLock(myMutex);</code>把myMutex和myUniLock绑定在了一起，也就是myUniLock拥有myMutex的所有权</p>
<ol>
<li class="lvl-3">
<p>使用move转移</p>
</li>
</ol>
<p>myUniLock1拥有myMutex的所有权，myUniLock1可以把自己对myMutex的所有权转移，但是不能复制。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inMsgRecvQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;inMsgRecvQueue()执行&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">myUniLock1</span><span class="params">(my_mutex)</span></span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;myUniLock1的地址为&quot;</span> &lt;&lt; &amp;myUniLock1 &lt;&lt; endl;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">myUniLock2</span><span class="params">(std::move(myUniLock1))</span></span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;myUniLock2的地址为&quot;</span> &lt;&lt; &amp;myUniLock2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        msgRecvQueue.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>构造一个返回值函数转移</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">return_unique_lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">myUniLock</span><span class="params">(my_mutex)</span></span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;函数中myUniLock的地址为&quot;</span> &lt;&lt; &amp;myUniLock &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//移动构造函数那里讲从函数返回一个局部的unique_lock对象是可以的</span></span><br><span class="line">    <span class="comment">//返回这种局部对象会导致系统生成临时的unique_lock对象，并调用unique_lock的移动构造函数</span></span><br><span class="line">    <span class="keyword">return</span> myUniLock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程一：从玩家收到的消息入到一个队列的线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inMsgRecvQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;inMsgRecvQueue()执行&quot;</span> &lt;&lt; endl;</span><br><span class="line">        unique_lock&lt;mutex&gt; myUniLock = <span class="built_in">return_unique_lock</span>();</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;myUniLock的地址为&quot;</span> &lt;&lt; &amp;myUniLock &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        msgRecvQueue.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="条件变量condition-variable">条件变量condition_variable</h3>
<h4 id="wait-notify-one">wait(), notify_one()</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>wait()</code>用于等待，当lambda表达式返回true时，<code>wait()</code>直接返回；当lambda表达式返回false时，<code>wait()</code>将解锁互斥量，并在本行堵塞，堵塞直到某个线程调用<code>notify_one()</code>成员函数为止</p>
</li>
<li class="lvl-2">
<p>如果wait()没有第二个参数，则与lambda表达式返回false的效果一样,即在本行堵塞，直到某个线程调用notify_one()成员函数</p>
</li>
<li class="lvl-2">
<p>当其他线程用<code>notify_one()</code>堵塞的<code>wait()</code>唤醒后，<mark>wait()线程将不断尝试获取锁</mark>(注：不一定能狗立刻获取到锁)</p>
</li>
<li class="lvl-2">
<p>假如<code>wait()</code>所在线程正在执行其余代码段，并不处于<code>wait()</code>的状态，此时<code>notify_one()</code>无效果(相当于宣告一直没锁)</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">// 模型发送消息</span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">inMsgRecvQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;Running inMsgRecvQueue(), insert one elem&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">				<span class="function">unique_lock&lt;mutex&gt; <span class="title">guard1</span><span class="params">(mutex1)</span></span>;</span><br><span class="line">				msgRecvQueue.<span class="built_in">push_back</span>(i);</span><br><span class="line">				</span><br><span class="line">				cond.<span class="built_in">notify_one</span>();	<span class="comment">// 将wait()所在线程唤醒</span></span><br><span class="line">				<span class="comment">// 假如wait()所在线程正在执行其余代码段，并不处于wait()的状态，此时notify_one()无效果</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 模拟取消息</span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">outMsgRecvQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="type">int</span> command = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">guard1</span><span class="params">(mutex1)</span></span>;</span><br><span class="line">				<span class="comment">// wait()用于等待，当lambda表达式返回true时，wait()直接返回</span></span><br><span class="line">				<span class="comment">// 当lambda表达式返回false时，wait()将解锁互斥量，并在本行堵塞</span></span><br><span class="line">				<span class="comment">// 堵塞直到某个线程调用notify_one()成员函数为止</span></span><br><span class="line">				<span class="comment">// 如果wait()没有第二个参数，则与lambda表达式返回false的效果一样</span></span><br><span class="line">				<span class="comment">// 即在本行堵塞，直到某个线程调用notify_one()成员函数</span></span><br><span class="line">				<span class="comment">// 当其他线程用notify_one()堵塞的wait()唤醒后，wait()线程将不断尝试获取锁</span></span><br><span class="line">				<span class="comment">// 当wait()成功获取锁后，将加锁并执行里面的内容（重新判断lambda表达式）</span></span><br><span class="line">				cond.<span class="built_in">wait</span>(guard1, [<span class="keyword">this</span>]&#123;</span><br><span class="line">					<span class="keyword">if</span>(!msgRecvQueue.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">// 第二参数，判断要处理的公共数据是否存在</span></span><br><span class="line">				&#125;);</span><br><span class="line">	</span><br><span class="line">				<span class="comment">// lambda表达式返回true，执行下面的内容</span></span><br><span class="line">				command = msgRecvQueue.<span class="built_in">front</span>();</span><br><span class="line">				msgRecvQueue.<span class="built_in">pop_front</span>();</span><br><span class="line">				guard1.<span class="built_in">unlock</span>(); <span class="comment">// unique_lock可以随时解锁</span></span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;Running outMsgRecvQueue(), get one elem: &quot;</span>&lt;&lt; command &lt;&lt; endl;</span><br><span class="line">				<span class="keyword">if</span>(command == <span class="number">999</span>) <span class="keyword">break</span>; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		mutex mutex1;</span><br><span class="line">		list&lt;<span class="type">int</span>&gt; msgRecvQueue;</span><br><span class="line">		condition_variable cond;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="function">std::thread <span class="title">OutMsg</span><span class="params">(&amp;A::outMsgRecvQueue, &amp;a)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">InMsg</span><span class="params">(&amp;A::inMsgRecvQueue, &amp;a)</span></span>;</span><br><span class="line">    OutMsg.<span class="built_in">join</span>();</span><br><span class="line">    InMsg.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="notify-all">notify_all()</h4>
<p><code>notify_all()</code>可以同时唤醒多个线程，，当多个线程都会等待被唤醒时，所有线程都会被唤醒；（被唤醒的多个线程可能会竞争同一个互斥锁（假设线程共用一个锁））</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">// 模型发送消息</span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">inMsgRecvQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;Running inMsgRecvQueue(), insert one elem&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">				<span class="function">unique_lock&lt;mutex&gt; <span class="title">guard1</span><span class="params">(mutex1)</span></span>;</span><br><span class="line">				msgRecvQueue.<span class="built_in">push_back</span>(i);</span><br><span class="line">				</span><br><span class="line">				cond.<span class="built_in">notify_all</span>();	<span class="comment">// 将wait()所在线程唤醒</span></span><br><span class="line">				<span class="comment">// 假如wait()所在线程正在执行其余代码段，并不处于wait()的状态，此时notify_one()无效果</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 模拟取消息</span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">outMsgRecvQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="type">int</span> command = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">guard1</span><span class="params">(mutex1)</span></span>;</span><br><span class="line">				<span class="comment">// wait()用于等待，当lambda表达式返回true时，wait()直接返回</span></span><br><span class="line">				<span class="comment">// 当lambda表达式返回false时，wait()将解锁互斥量，并在本行堵塞</span></span><br><span class="line">				<span class="comment">// 堵塞直到某个线程调用notify_one()成员函数为止</span></span><br><span class="line">				<span class="comment">// 如果wait()没有第二个参数，则与lambda表达式返回false的效果一样</span></span><br><span class="line">				<span class="comment">// 即在本行堵塞，直到某个线程调用notify_one()成员函数</span></span><br><span class="line">				<span class="comment">// 当其他线程用notify_one()堵塞的wait()唤醒后，wait()线程将不断尝试获取锁</span></span><br><span class="line">				<span class="comment">// 当wait()成功获取锁后，将加锁并执行里面的内容（重新判断lambda表达式）</span></span><br><span class="line">				cond.<span class="built_in">wait</span>(guard1, [<span class="keyword">this</span>]&#123;</span><br><span class="line">					<span class="keyword">if</span>(!msgRecvQueue.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">				&#125;);</span><br><span class="line">	</span><br><span class="line">				<span class="comment">// lambda表达式返回true，执行下面的内容</span></span><br><span class="line">				command = msgRecvQueue.<span class="built_in">front</span>();</span><br><span class="line">				msgRecvQueue.<span class="built_in">pop_front</span>();</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;Running outMsgRecvQueue(), get one elem: &quot;</span>&lt;&lt; command &lt;&lt; <span class="string">&quot;  线程id&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">				guard1.<span class="built_in">unlock</span>(); <span class="comment">// unique_lock可以随时解锁</span></span><br><span class="line">				<span class="keyword">if</span>(command == <span class="number">999</span>) <span class="keyword">break</span>; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		mutex mutex1;</span><br><span class="line">		list&lt;<span class="type">int</span>&gt; msgRecvQueue;</span><br><span class="line">		condition_variable cond;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="function">std::thread <span class="title">OutMsg1</span><span class="params">(&amp;A::outMsgRecvQueue, &amp;a)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">OutMsg2</span><span class="params">(&amp;A::outMsgRecvQueue, &amp;a)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">InMsg</span><span class="params">(&amp;A::inMsgRecvQueue, &amp;a)</span></span>;</span><br><span class="line">    OutMsg1.<span class="built_in">join</span>();</span><br><span class="line">    OutMsg2.<span class="built_in">join</span>();</span><br><span class="line">    InMsg.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="超时锁">超时锁</h3>
<p><code>std::timed_mutex</code>带有超时功能的独占互斥量</p>
<h4 id="try-lock-for">try_lock_for()</h4>
<p><code>try_lock_for()</code>等待一段时间来尝试获取锁，若无法获取锁，则线程继续执行（跳过临界区的内容）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inMsgRecvQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::<span class="function">chrono::seconds <span class="title">timeout</span><span class="params">(<span class="number">100</span>)</span></span>;	<span class="comment">// 100ms</span></span><br><span class="line">        <span class="keyword">if</span>(my_mutex.<span class="built_in">try_lock_for</span>(timeout))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 100ms 内拿到了锁</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;inMsgRecvQueue()执行，插入一个元素:&quot;</span> &lt;&lt; i &lt;&lt; std::endl; </span><br><span class="line">            msgRecvqueue.<span class="built_in">push_back</span>(i); <span class="comment">// 消息队列存储消息</span></span><br><span class="line">            my_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取不成功</span></span><br><span class="line">            std::chrono::seconds <span class="built_in">sleeptime</span>(<span class="number">100</span>); <span class="comment">// 线程休息100ms</span></span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(sleeptime);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;can not get the lock&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="try-lock-until">try_lock_until()</h4>
<p><code>try_lock_until()</code>是直到某一时间内都在尝试获取锁，如果超过了规定的时间点仍无法获取锁，线程就会继续执行（跳过临界区的内容）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inMsgRecvQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::<span class="function">chrono::seconds <span class="title">timeout</span><span class="params">(<span class="number">100</span>)</span></span>;	<span class="comment">// 100ms</span></span><br><span class="line">        <span class="keyword">if</span>(my_mutex.<span class="built_in">try_lock_until</span>(std::chrono::steady_clock::<span class="built_in">now</span>() + timeout)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 100ms 内拿到了锁</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;inMsgRecvQueue()执行，插入一个元素:&quot;</span> &lt;&lt; i &lt;&lt; std::endl; </span><br><span class="line">            msgRecvqueue.<span class="built_in">push_back</span>(i); <span class="comment">// 消息队列存储消息</span></span><br><span class="line">            my_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取不成功</span></span><br><span class="line">            std::chrono::seconds <span class="built_in">sleeptime</span>(<span class="number">100</span>); <span class="comment">// 线程休息100ms</span></span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(sleeptime);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;can not get the lock&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归独占互斥量">递归独占互斥量</h3>
<p><code>std::recursive_mutex</code>创建递归的独占互斥量，允许一个线程对其多次加锁<code>lock()</code>和解锁<code>unlock()</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">std::recursive_mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">functionB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::recursive_mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;functionB() called by thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">functionA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::recursive_mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;functionA() called by thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">functionB</span>(); <span class="comment">// 在持有锁的情况下调用另一个可能加锁的函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">functionA</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(threadFunc)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(threadFunc)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单例设计模式共享数据">单例设计模式共享数据</h2>
<h3 id="单例设计模型">单例设计模型</h3>
<p>单例设计模式要求某一个类最多创建一个对象，这个对象即单例对象（全局唯一实例对象）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCAS</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">static</span> MyCAS *<span class="title">GetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(m_instance == <span class="literal">NULL</span>)&#123;</span><br><span class="line">				m_instance = <span class="keyword">new</span> <span class="built_in">MyCAS</span>(); </span><br><span class="line">				<span class="type">static</span> CGar c1;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> m_instance;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;test sample!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">CGar</span>&#123; <span class="comment">// 类中套类，用于释放对象</span></span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">			~<span class="built_in">CGar</span>()&#123;</span><br><span class="line">				<span class="keyword">if</span>(MyCAS::GetInstance)</span><br><span class="line">				&#123;</span><br><span class="line">					cout &lt;&lt; <span class="string">&quot;调用子类的析构函数，释放m_instance&quot;</span> &lt;&lt; endl;</span><br><span class="line">					<span class="keyword">delete</span> MyCAS::m_instance;</span><br><span class="line">					MyCAS::m_instance = <span class="literal">NULL</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="built_in">MyCAS</span>()&#123;&#125;; <span class="comment">// 私有化成员变量，不能通过构造函数来创建对象</span></span><br><span class="line">		<span class="type">static</span> MyCAS *m_instance; <span class="comment">// 静态成员变量</span></span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 静态数据成员类外初始化</span></span><br><span class="line">MyCAS* MyCAS::m_instance = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyCAS *sample1 = MyCAS::<span class="built_in">GetInstance</span>(); <span class="comment">// 创建对象，返回该类对象的指针</span></span><br><span class="line">    MyCAS *sample2 = MyCAS::<span class="built_in">GetInstance</span>(); <span class="comment">// 创建对象，返回该类对象的指针</span></span><br><span class="line">    cout &lt;&lt; sample1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; sample2 &lt;&lt; endl; <span class="comment">// 两个指针指向同一个对象</span></span><br><span class="line"> </span><br><span class="line">    sample1-&gt;<span class="built_in">func</span>(); <span class="comment">// 调用成员函数测试</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x15be05e70 0x15be05e70</span><br><span class="line">test sample!</span><br><span class="line">调用子类的析构函数，释放m_instance</span><br></pre></td></tr></table></figure>
<h3 id="数据竞争">数据竞争</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCAS</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> MyCAS *<span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_instance == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_instance = <span class="keyword">new</span> <span class="built_in">MyCAS</span>();</span><br><span class="line">            <span class="type">static</span> CGar c1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;test sample!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">CGar</span>&#123; <span class="comment">// 类中套类，用于释放对象</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~<span class="built_in">CGar</span>()&#123;</span><br><span class="line">            <span class="keyword">if</span>(MyCAS::GetInstance)&#123;</span><br><span class="line">                <span class="keyword">delete</span> MyCAS::m_instance;</span><br><span class="line">                MyCAS::m_instance = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">MyCAS</span>()&#123;&#125;; <span class="comment">// 私有化成员变量，不能通过构造函数来创建对象</span></span><br><span class="line">    <span class="type">static</span> MyCAS *m_instance; <span class="comment">// 静态成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 静态数据成员类外初始化</span></span><br><span class="line">MyCAS* MyCAS::m_instance = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 线程入口函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mythread</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;start thread&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    MyCAS *p_a = MyCAS::<span class="built_in">GetInstance</span>();</span><br><span class="line">    p_a-&gt;<span class="built_in">func</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;thread end&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">thread1</span><span class="params">(mythread)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">thread2</span><span class="params">(mythread)</span></span>;</span><br><span class="line">    thread1.<span class="built_in">join</span>();</span><br><span class="line">    thread2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题：可能两个线程会同时进入<code>if(m_instance == NULL)</code>的判断语句，导致多个线程同时创建类对象的情况</p>
<p>解决方法：加入互斥量，保证只有一个<code>if(m_instance == NULL)</code>会执行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> MyCAS *<span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">guard1</span><span class="params">(mutex1)</span></span>; <span class="comment">// 自动加锁和解锁</span></span><br><span class="line">	<span class="keyword">if</span>(m_instance == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		m_instance = <span class="keyword">new</span> <span class="built_in">MyCAS</span>();</span><br><span class="line">		<span class="type">static</span> CGar c1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题：线程每一次创建时都需要调用<code>std::unique_lock&lt;std::mutex&gt; guard1(mutex1);</code>，效率低下</p>
<h3 id="双重检验锁">双重检验锁</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> MyCAS *<span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 双重检查锁</span></span><br><span class="line">	<span class="keyword">if</span>(m_instance == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">guard1</span><span class="params">(mutex1)</span></span>; <span class="comment">// 自动加锁和解锁</span></span><br><span class="line">		<span class="keyword">if</span>(m_instance == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			m_instance = <span class="keyword">new</span> <span class="built_in">MyCAS</span>();</span><br><span class="line">			<span class="type">static</span> CGar c1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="call-once">call_once()</h3>
<p><code>std::call_once()</code>的功能是确保函数 <code>func()</code> 只会被调用一次；（即 <code>std::call_once()</code> 具有互斥量的能力，相对于互斥量其消耗的资源更少）</p>
<p><code>std::call_once()</code> 需要和一个标记进行结合使用，这个标记决定对象的函数 <code>func()</code> 是否被调用；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"> </span><br><span class="line">std::once_flag g_flag; <span class="comment">// 系统定义的标记</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCAS</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">CreateInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        m_instance = <span class="keyword">new</span> <span class="built_in">MyCAS</span>();</span><br><span class="line">        <span class="type">static</span> CGar c1;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> MyCAS *<span class="title">GetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// std::call_once 确保创建单例对象的函数只会被调用一次</span></span><br><span class="line">        std::<span class="built_in">call_once</span>(g_flag, CreateInstance);</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;test sample!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">CGar</span>&#123; <span class="comment">// 类中套类，用于释放对象</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~<span class="built_in">CGar</span>()&#123;</span><br><span class="line">            <span class="keyword">if</span>(MyCAS::GetInstance)&#123;</span><br><span class="line">                <span class="keyword">delete</span> MyCAS::m_instance;</span><br><span class="line">                MyCAS::m_instance = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">MyCAS</span>()&#123;&#125;; <span class="comment">// 私有化成员变量，不能通过构造函数来创建对象</span></span><br><span class="line">    <span class="type">static</span> MyCAS *m_instance; <span class="comment">// 静态成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 静态数据成员类外初始化</span></span><br><span class="line">MyCAS* MyCAS::m_instance = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 线程入口函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mythread</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;start thread&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    MyCAS *p_a = MyCAS::<span class="built_in">GetInstance</span>();</span><br><span class="line">    p_a-&gt;<span class="built_in">func</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread end&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">thread1</span><span class="params">(mythread)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">thread2</span><span class="params">(mythread)</span></span>;</span><br><span class="line">    thread1.<span class="built_in">join</span>();</span><br><span class="line">    thread2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="原子操作">原子操作</h2>
<p>原子操作<code>std::atomic</code>是一种在多线程环境下不可分割的操作，确保操作不会被其他线程中断。这对于保证数据一致性和避免数据竞争非常重要。原子操作通常适用于对<mark>单个变量</mark>的操作，而不是一段代码或多个变量(使用互斥量)。</p>
<ol>
<li class="lvl-3">
<p><strong>高效性</strong>：原子操作通常比使用互斥量（<code>std::mutex</code>）进行加锁和解锁更高效，因为原子操作在硬件层面提供了支持。</p>
</li>
<li class="lvl-3">
<p><strong>线程安全</strong>：原子操作保证了在多线程环境下操作的完整性，避免了数据竞争问题。</p>
</li>
<li class="lvl-3">
<p><strong>简洁性</strong>：使用原子操作可以简化代码，因为不需要显式地进行锁定和解锁操作。</p>
</li>
</ol>
<p>原子操作的适用场景包括但不限于以下几种：</p>
<ol>
<li class="lvl-3">
<p><strong>计数器</strong>：如全局计数器、访问计数器等。</p>
</li>
<li class="lvl-3">
<p><strong>标志变量</strong>：如状态标志、完成标志等。</p>
</li>
<li class="lvl-3">
<p><strong>指针操作</strong>：如原子指针的读取和写入。</p>
</li>
<li class="lvl-3">
<p><strong>简洁的条件检查和交换操作</strong>：如比较并交换（compare-and-swap）。</p>
</li>
</ol>
<h3 id="计数器">计数器</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">incrementCounter</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">        threads.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(incrementCounter, <span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : threads)</span><br><span class="line">	&#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final counter value: &quot;</span> &lt;&lt; counter &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="标志变量">标志变量</h3>
<p>原子操作可以用于设置和检查标志变量，例如在多线程环境下通知某些状态变化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">ready</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">waitForReady</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::<span class="function">chrono::seconds <span class="title">dura</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (!ready)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;thread runs 1s&quot;</span> &lt;&lt; endl;</span><br><span class="line">    	std::this_thread::<span class="built_in">sleep_for</span>(dura);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; proceeds.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(waitForReady)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(waitForReady)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    ready = <span class="literal">true</span>; <span class="comment">// 设置标志变量</span></span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指针操作">指针操作</h3>
<p><code>.store()</code>以原子方式写入内容，<code>.load()</code>以原子方式读对象的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>*&gt; <span class="title">atomic_ptr</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setPointer</span><span class="params">(<span class="type">int</span>* ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    atomic_ptr.<span class="built_in">store</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">usePointer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!atomic_ptr.<span class="built_in">load</span>())</span><br><span class="line">	&#123;</span><br><span class="line">        std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Pointer value: &quot;</span> &lt;&lt; *atomic_ptr.<span class="built_in">load</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">42</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(usePointer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(setPointer, &amp;value)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="比较并交换">比较并交换</h3>
<p><strong>expected</strong>：这是一个左值引用，表示预期的旧值。如果原子变量的当前值与 <code>expected</code> 相等，则将其更新为 <code>desired</code>，否则将原子变量的当前值写回 <code>expected</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">atomic_val</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">compareAndSwap</span><span class="params">(<span class="type">int</span> oldVal, <span class="type">int</span> newVal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> expected = oldVal;	<span class="comment">// 初始化 expected 为 oldVal</span></span><br><span class="line">    <span class="keyword">if</span> (atomic_val.<span class="built_in">compare_exchange_strong</span>(expected, newVal))</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 如果 atomic_val 当前值等于 expected（即 oldVal），则将其更新为 newVal</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; updated the value to &quot;</span> &lt;&lt; newVal &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 否则，将 atomic_val 当前值写回 expected</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; failed to update the value. Current value is &quot;</span> &lt;&lt; atomic_val.<span class="built_in">load</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(compareAndSwap, <span class="number">0</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(compareAndSwap, <span class="number">0</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Final value: &quot;</span> &lt;&lt; atomic_val.<span class="built_in">load</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>future成员函数</h1>
<h2 id="std-async">std::async</h2>
<p><code>std::async</code> 创建一个<strong>异步任务</strong>，其不一定会创建一个新线程去执行该任务；</p>
<h3 id="传递普通函数">传递普通函数</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mythread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;thread start, id: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">5000</span>;	<span class="comment">// 休息5s</span></span><br><span class="line">	std::<span class="function">chrono::microseconds <span class="title">dura</span><span class="params">(value)</span></span>; <span class="comment">// rest</span></span><br><span class="line">	std::this_thread::<span class="built_in">sleep_for</span>(dura);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;thread end, id: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// std::async用于启动一个异步任务，并返回一个std::future对象</span></span><br><span class="line">    <span class="comment">// std::future对象里含有异步任务线程入口函数的结果</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main thread id: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = std::<span class="built_in">async</span>(mythread);	<span class="comment">// 创建一个线程并开始执行</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// result.get()等待thread()执行完毕获取结果后，主线程才继续往下执行</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;resule.get(): &quot;</span> &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; endl; </span><br><span class="line">    <span class="comment">// get()只能调用一次不能调用多次</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// result.wait() // 等待线程返回，但不返回结果</span></span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main thread continue ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main thread id: 0x1fc76fac0</span><br><span class="line">resule.get(): thread start, id: 0x16b143000</span><br><span class="line">thread end, id: 0x16b143000</span><br><span class="line">5</span><br><span class="line">main thread continue ...</span><br></pre></td></tr></table></figure>
<h3 id="传递类成员函数">传递类成员函数</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">mythread</span><span class="params">(<span class="type">int</span> mypar)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			cout &lt;&lt; mypar &lt;&lt; endl;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;thread start, id: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">			<span class="type">int</span> value = <span class="number">5000</span>;	<span class="comment">// 休息5s</span></span><br><span class="line">			std::<span class="function">chrono::microseconds <span class="title">dura</span><span class="params">(value)</span></span>; <span class="comment">// rest</span></span><br><span class="line">			std::this_thread::<span class="built_in">sleep_for</span>(dura);</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;thread end, id: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	<span class="type">int</span> temp = <span class="number">666</span>;</span><br><span class="line">    <span class="comment">// std::async用于启动一个异步任务，并返回一个std::future对象</span></span><br><span class="line">    <span class="comment">// std::future对象里含有异步任务线程入口函数的结果</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main thread id: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = std::<span class="built_in">async</span>(&amp;A::mythread, &amp;a, temp);	<span class="comment">// 第二个参数是对象引用</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// result.get()等待thread()执行完毕获取结果后，主线程才继续往下执行</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;resule.get(): &quot;</span> &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// result.wait() // 等待线程返回，但不返回结果</span></span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main thread continue ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main thread id: 0x1fc76fac0</span><br><span class="line">resule.get(): 666</span><br><span class="line">thread start, id: 0x16bc5f000</span><br><span class="line">thread end, id: 0x16bc5f000</span><br><span class="line">5</span><br><span class="line">main thread continue ...</span><br></pre></td></tr></table></figure>
<h3 id="延迟调用">延迟调用</h3>
<p><code>std::launch::deferred</code>表示调用线程入口函数将会被延迟到<code>std::future</code>的<code>wait()</code>或<code>get()</code>调用，当<code>wait()</code>或者<code>get()</code>没有被调用时，线程入口函数不会被调用(线程不会被创建)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::future&lt;<span class="type">int</span>&gt; result = std::<span class="built_in">async</span>(std::launch::deferred, &amp;A::mythread, &amp;a, temp);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main thread id: 0x1fc76fac0</span><br><span class="line">resule.get(): 666</span><br><span class="line">thread start, id: 0x1fc76fac0</span><br><span class="line">thread end, id: 0x1fc76fac0</span><br><span class="line">5</span><br><span class="line">main thread continue ...</span><br></pre></td></tr></table></figure>
<p>并没有创建新线程，是在主线程中调用的线程入口函数</p>
<p>参数<code>std::launch::async</code>，操作系统会<strong>强制创建一个新线程</strong>来执行异步任务(同步运行)</p>
<p>默认参数是<code>std::launch::async | std::launch::deferred</code>，操作系统会同步运行或者延迟调用</p>
<h3 id="std-future-status">std::future_status</h3>
<p><code>std::future_status</code> 包含以下三个值：</p>
<ol>
<li class="lvl-3">
<p><strong><code>std::future_status::ready</code></strong>：表示异步操作已经完成，结果已经准备好，可以调用 <code>future.get()</code> 来获取结果。</p>
</li>
<li class="lvl-3">
<p><strong><code>std::future_status::timeout</code></strong>：表示在指定的等待时间内，异步操作还没有完成。</p>
</li>
<li class="lvl-3">
<p><strong><code>std::future_status::deferred</code></strong>：表示异步操作被延迟执行，仅在调用 <code>future.get()</code> 或 <code>future.wait()</code> 时才会执行。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sample</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 线程入口函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">thread</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread id: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">        std::<span class="function">chrono::seconds <span class="title">dura</span><span class="params">(value)</span></span>; <span class="comment">// rest</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(dura);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Sample sample;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main thread id: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动异步操作</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = std::<span class="built_in">async</span>(&amp;Sample::thread, &amp;sample, value);</span><br><span class="line">    <span class="comment">// std::launch::deferred 设置延迟执行状态</span></span><br><span class="line">    <span class="comment">// std::future&lt;int&gt; result = std::async(std::launch::deferred, &amp;Sample::thread, &amp;sample, value);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待 1 秒钟</span></span><br><span class="line">    std::future_status status = result.<span class="built_in">wait_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status == std::future_status::timeout)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// 超时，因为线程里面睡眠了 3 秒</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread timeout!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(status == std::future_status::ready)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// 线程在等待期间成功返回</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;result.get(): &quot;</span> &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(status == std::future_status::deferred)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// 延迟执行状态</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;deferred, result.get(): &quot;</span> &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;main thread continue ...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Thread与saync区别">Thread与saync区别</h3>
<p>如果使用<code>std::thread</code>创建的线程太多导致系统资源紧张，可能创建失败，系统报告异常</p>
<p>如果使用<code>std::async</code>创建的任务过多导致系统资源紧张，不会报告异常不会崩溃。如果系统因为资源紧张无法创建新线程的时候，<code>std::async</code>不会创建新线程，而是后续调用<code>result.get()</code>请求结果，异步任务就运行在<code>result.get()</code>语句所在的线程上。</p>
<p>判断异步任务的执行状态</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">threadFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Thread function id: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Main thread id: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动异步任务</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = std::<span class="built_in">async</span>(std::launch::deferred | std::launch::async, threadFunc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待0秒，立即检查异步任务的状态</span></span><br><span class="line">    std::future_status status = result.<span class="built_in">wait_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status == std::future_status::deferred)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 异步任务会延迟执行</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Task is deferred, running in the main thread.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建新线程来执行异步任务</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Task is running in a new thread.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; endl; <span class="comment">// 获取结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="std-shared-future">std::shared_future</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程入口函数，模拟一些计算任务</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compute</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Computing in thread id: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(value)); <span class="comment">// 模拟计算</span></span><br><span class="line">    <span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printResult</span><span class="params">(shared_future&lt;<span class="type">int</span>&gt; fut, <span class="type">int</span> threadNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; threadNum &lt;&lt; <span class="string">&quot; id: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; waiting for result...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> result = fut.<span class="built_in">get</span>(); <span class="comment">// 获取共享结果</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; threadNum &lt;&lt; <span class="string">&quot; received result: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Main thread id: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::async 启动异步操作，并获取 future 对象</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; fut = std::<span class="built_in">async</span>(compute, value);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 future 转换为 shared_future</span></span><br><span class="line">    std::shared_future&lt;<span class="type">int</span>&gt; sharedFut = fut.<span class="built_in">share</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建多个线程，使用 shared_future 来获取结果</span></span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(printResult, sharedFut, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : threads) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Main thread continue ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Main thread id: 0x1fc76fac0</span><br><span class="line">Computing in thread id: 0x16dc07000</span><br><span class="line">Thread 1 id: 0x16dc93000 waiting for result...</span><br><span class="line">Thread 2 id: 0x16dd1f000 waiting for result...</span><br><span class="line">Thread 3 id: 0x16ddab000 waiting for result...</span><br><span class="line">Thread Thread 12 received result:  received result: 66</span><br><span class="line"></span><br><span class="line">Thread 3 received result: 6</span><br><span class="line">Main thread continue ...</span><br></pre></td></tr></table></figure>
<h2 id="std-packaged-task">std::packaged_task</h2>
<p><code>std::packaged_task</code>用于打包任务，其包装各种可调用对象，方便后续作为线程入口函数</p>
<h3 id="包装普通子函数">包装普通子函数</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mythread</span><span class="params">(<span class="type">int</span> mypar)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; mypar &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;thread start, id: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">5000</span>;	<span class="comment">// 休息5s</span></span><br><span class="line">	std::<span class="function">chrono::microseconds <span class="title">dura</span><span class="params">(value)</span></span>; <span class="comment">// rest</span></span><br><span class="line">	std::this_thread::<span class="built_in">sleep_for</span>(dura);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;thread end, id: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main thread id: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>)</span>&gt; <span class="title">mypt</span><span class="params">(mythread)</span></span>;	<span class="comment">// 把函数mythread通过packaged_task包装起来</span></span><br><span class="line">	</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(std::ref(mypt), <span class="number">666</span>)</span></span>;	<span class="comment">// 线程开始执行，第二个参数作为线程入口函数的参数</span></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = mypt.<span class="built_in">get_future</span>();	<span class="comment">// std::future对象里包含有线程入口函数的返回结果</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;result.get(): &quot;</span> &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main thread continue ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="包装lamda表达式">包装lamda表达式</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>)</span>&gt; <span class="title">mypt</span><span class="params">([](<span class="type">int</span> mypar)&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    cout &lt;&lt; mypar &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    cout &lt;&lt; <span class="string">&quot;thread start, id: &quot;</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> value = <span class="number">5000</span>;	<span class="comment">// 休息5s</span></span></span></span><br><span class="line"><span class="params"><span class="function">    std::chrono::microseconds dura(value); <span class="comment">// rest</span></span></span></span><br><span class="line"><span class="params"><span class="function">    std::this_thread::sleep_for(dura);</span></span></span><br><span class="line"><span class="params"><span class="function">    cout &lt;&lt; <span class="string">&quot;thread end, id: &quot;</span> &lt;&lt; this_thread::get_id() &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">return</span> <span class="number">5</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;	</span><br></pre></td></tr></table></figure>
<h3 id="直接调用包装函数">直接调用包装函数</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mypt</span>(<span class="number">666</span>);</span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; result = mypt.<span class="built_in">get_future</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;result.get(): &quot;</span> &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main thread id: 0x1fc76fac0</span><br><span class="line">666</span><br><span class="line">thread start, id: 0x1fc76fac0</span><br><span class="line">thread end, id: 0x1fc76fac0</span><br><span class="line">result.get(): 5</span><br><span class="line">main thread continue ...</span><br></pre></td></tr></table></figure>
<p>没有创建子线程，都在主线程中执行</p>
<h2 id="std-promise">std::promise()</h2>
<p><code>std::promise</code>用于在其他线程中使用某个线程中的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1_func</span><span class="params">(promise&lt;<span class="type">int</span>&gt;&amp; prom)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;thread1_func thread id: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 模拟一些计算</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">    <span class="type">int</span> result = <span class="number">42</span>;</span><br><span class="line">    prom.<span class="built_in">set_value</span>(result);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Thread 1: value set to &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2_func</span><span class="params">(future&lt;<span class="type">int</span>&gt;&amp; fut)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;thread2_func thread id: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> value = fut.<span class="built_in">get</span>(); <span class="comment">// 阻塞等待，直到获取值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Thread 2: value read as &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main thread id: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    promise&lt;<span class="type">int</span>&gt; prom;</span><br><span class="line">    future&lt;<span class="type">int</span>&gt; fut = prom.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(thread1_func, std::ref(prom))</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(thread2_func, std::ref(fut))</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main thread id: 0x1fc76fac0</span><br><span class="line">thread1_func thread id: 0x16f7ff000</span><br><span class="line">thread2_func thread id: 0x16f88b000</span><br><span class="line">Thread 1: value set to 42</span><br><span class="line">Thread 2: value read as 42</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">花瓶</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/06/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">http://example.com/2024/06/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">花瓶里的芝士不收费</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-C/">C/C++</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></div><div class="post_share"><div class="social-share" data-image="/img/The_Nightwatch.jpg" data-sites="qq,wechat,weibo"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/06/18/%E5%BF%83%E7%90%86%E7%BB%9F%E8%AE%A1/" title="心理统计"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/lazyload.gif" data-original="/img/Starry_Night.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">心理统计</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/08/28/%E5%90%83%E8%B1%86%E4%BA%BA%E5%A4%A7%E9%80%83%E4%BA%A1/" title="吃豆人大逃亡"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/lazyload.gif" data-original="/img/Women_of_Amphissa.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-28</div><div class="title">吃豆人大逃亡</div></div></a></div><div><a href="/2023/01/29/%E6%8E%92%E5%BA%8F%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95/" title="排序选择算法"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/lazyload.gif" data-original="/img/Figure_in_a_Room.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-29</div><div class="title">排序选择算法</div></div></a></div><div><a href="/2022/08/25/%E6%8C%87%E9%92%88%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93/" title="指针与结构体"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/lazyload.gif" data-original="/img/Starry_Night.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-25</div><div class="title">指针与结构体</div></div></a></div><div><a href="/2024/03/07/%E5%9B%BE%E8%AE%BA/" title="图论"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/lazyload.gif" data-original="/img/Women_of_Amphissa.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-07</div><div class="title">图论</div></div></a></div><div><a href="/2022/10/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="数据结构"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/lazyload.gif" data-original="/img/Starry_Night.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-19</div><div class="title">数据结构</div></div></a></div><div><a href="/2023/07/31/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/" title="高级数据结构"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/lazyload.gif" data-original="/img/The_Nightwatch.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-31</div><div class="title">高级数据结构</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/lazyload.gif" data-original="/img/John_King.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">花瓶</div><div class="author-info__description">简简单单的小花瓶~</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/robust-vase"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/robust-vase" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:robustvase@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://www.zhihu.com/people/yu-xia-si-can-hong" target="_blank" title="zhihu"><i class="fab fa-zhihu"></i></a><a class="social-icon" href="https://space.bilibili.com/197525661" target="_blank" title="bilibili"><i class="fab fa-bilibili"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><center style="color: var(--theme-color)">
  <b><span style="font-size: 20px">花瓶简介</span><br>
  从<span style="font-size: 16px">计算数学</span>转到<span style="font-size: 16px">心理学</span>的花瓶～<br>
  时不时发布算法👨🏻‍💻相关笔记<br>
  或许是单细胞测序🧬内容<br>
  👋关注花瓶的都是现实中的朋友啦～<br>
  🚀<span style="font-size: 16px">花瓶持续更新～</span>🚀<br>
  </b>
</center>
</div><div id="welcome-info"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91"><span class="toc-number">2.1.</span> <span class="toc-text">并发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.2.</span> <span class="toc-text">可执行的程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.4.</span> <span class="toc-text">线程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">创建多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">使用函数对象创建线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">使用类对象创建线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lamda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.3.</span> <span class="toc-text">lamda表达式创建线程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">传递临时对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92%E4%B8%8E%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92"><span class="toc-number">4.1.</span> <span class="toc-text">值传递与指针传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E4%B8%B4%E6%97%B6%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.2.</span> <span class="toc-text">传递临时类对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E4%BD%BF%E7%94%A8%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E4%BC%A0%E9%80%92"><span class="toc-number">4.2.1.</span> <span class="toc-text">不使用临时对象传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E4%BC%A0%E9%80%92"><span class="toc-number">4.2.2.</span> <span class="toc-text">使用临时对象传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E5%86%85%E5%8F%82%E6%95%B0"><span class="toc-number">4.2.3.</span> <span class="toc-text">修改临时对象内参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.3.</span> <span class="toc-text">智能指针传递临时对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">4.4.</span> <span class="toc-text">成员函数指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">4.4.1.</span> <span class="toc-text">调用运算符重载</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">创建多个线程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">数据共享问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E6%95%B0%E6%8D%AE"><span class="toc-number">6.1.</span> <span class="toc-text">只读数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8B%AC%E5%8D%A0%E4%BA%92%E6%96%A5%E9%87%8F"><span class="toc-number">6.2.</span> <span class="toc-text">独占互斥量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#lock-%EF%BC%8Cunlock"><span class="toc-number">6.2.1.</span> <span class="toc-text">lock()，unlock()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#std-lock-guard%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">6.2.2.</span> <span class="toc-text">std::lock_guard类模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">6.2.3.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E7%A4%BA%E8%8C%83"><span class="toc-number">6.2.3.1.</span> <span class="toc-text">错误示范</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F%E7%9A%84lock-%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4"><span class="toc-number">6.2.3.2.</span> <span class="toc-text">互斥量的lock()顺序一致</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#std-lock-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">6.2.3.3.</span> <span class="toc-text">std::lock()函数模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#std-lock-guard%E7%9A%84std-adopt-lock%E5%8F%82%E6%95%B0"><span class="toc-number">6.2.3.4.</span> <span class="toc-text">std::lock_guard的std::adopt_lock参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-lock-%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">6.2.4.</span> <span class="toc-text">unique_lock()类模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%96%E4%BB%A3lock-guard"><span class="toc-number">6.2.4.1.</span> <span class="toc-text">取代lock_guard()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0"><span class="toc-number">6.2.4.2.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">6.2.4.3.</span> <span class="toc-text">成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E6%9D%83%E7%9A%84%E4%BC%A0%E9%80%92"><span class="toc-number">6.2.4.4.</span> <span class="toc-text">所有权的传递</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8Fcondition-variable"><span class="toc-number">6.2.5.</span> <span class="toc-text">条件变量condition_variable</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#wait-notify-one"><span class="toc-number">6.2.5.1.</span> <span class="toc-text">wait(), notify_one()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#notify-all"><span class="toc-number">6.2.5.2.</span> <span class="toc-text">notify_all()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E9%94%81"><span class="toc-number">6.2.6.</span> <span class="toc-text">超时锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#try-lock-for"><span class="toc-number">6.2.6.1.</span> <span class="toc-text">try_lock_for()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#try-lock-until"><span class="toc-number">6.2.6.2.</span> <span class="toc-text">try_lock_until()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%8B%AC%E5%8D%A0%E4%BA%92%E6%96%A5%E9%87%8F"><span class="toc-number">6.2.7.</span> <span class="toc-text">递归独占互斥量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE"><span class="toc-number">6.3.</span> <span class="toc-text">单例设计模式共享数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.3.1.</span> <span class="toc-text">单例设计模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89"><span class="toc-number">6.3.2.</span> <span class="toc-text">数据竞争</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E9%87%8D%E6%A3%80%E9%AA%8C%E9%94%81"><span class="toc-number">6.3.3.</span> <span class="toc-text">双重检验锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#call-once"><span class="toc-number">6.3.4.</span> <span class="toc-text">call_once()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">6.4.</span> <span class="toc-text">原子操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">6.4.1.</span> <span class="toc-text">计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%BF%97%E5%8F%98%E9%87%8F"><span class="toc-number">6.4.2.</span> <span class="toc-text">标志变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%93%8D%E4%BD%9C"><span class="toc-number">6.4.3.</span> <span class="toc-text">指针操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%B9%B6%E4%BA%A4%E6%8D%A2"><span class="toc-number">6.4.4.</span> <span class="toc-text">比较并交换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">future成员函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#std-async"><span class="toc-number">7.1.</span> <span class="toc-text">std::async</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0"><span class="toc-number">7.1.1.</span> <span class="toc-text">传递普通函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">7.1.2.</span> <span class="toc-text">传递类成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E8%B0%83%E7%94%A8"><span class="toc-number">7.1.3.</span> <span class="toc-text">延迟调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#std-future-status"><span class="toc-number">7.1.4.</span> <span class="toc-text">std::future_status</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread%E4%B8%8Esaync%E5%8C%BA%E5%88%AB"><span class="toc-number">7.1.5.</span> <span class="toc-text">Thread与saync区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#std-shared-future"><span class="toc-number">7.1.6.</span> <span class="toc-text">std::shared_future</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#std-packaged-task"><span class="toc-number">7.2.</span> <span class="toc-text">std::packaged_task</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E6%99%AE%E9%80%9A%E5%AD%90%E5%87%BD%E6%95%B0"><span class="toc-number">7.2.1.</span> <span class="toc-text">包装普通子函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85lamda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">7.2.2.</span> <span class="toc-text">包装lamda表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8%E5%8C%85%E8%A3%85%E5%87%BD%E6%95%B0"><span class="toc-number">7.2.3.</span> <span class="toc-text">直接调用包装函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#std-promise"><span class="toc-number">7.3.</span> <span class="toc-text">std::promise()</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/06/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="多线程"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/lazyload.gif" data-original="/img/The_Nightwatch.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="多线程"/></a><div class="content"><a class="title" href="/2024/06/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="多线程">多线程</a><time datetime="2024-06-23T13:52:30.000Z" title="发表于 2024-06-23 21:52:30">2024-06-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/18/%E5%BF%83%E7%90%86%E7%BB%9F%E8%AE%A1/" title="心理统计"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/lazyload.gif" data-original="/img/Starry_Night.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="心理统计"/></a><div class="content"><a class="title" href="/2024/06/18/%E5%BF%83%E7%90%86%E7%BB%9F%E8%AE%A1/" title="心理统计">心理统计</a><time datetime="2024-06-18T01:05:58.000Z" title="发表于 2024-06-18 09:05:58">2024-06-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/07/%E5%9B%BE%E8%AE%BA/" title="图论"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/lazyload.gif" data-original="/img/Women_of_Amphissa.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="图论"/></a><div class="content"><a class="title" href="/2024/03/07/%E5%9B%BE%E8%AE%BA/" title="图论">图论</a><time datetime="2024-03-07T10:12:27.000Z" title="发表于 2024-03-07 18:12:27">2024-03-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/31/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/" title="高级数据结构"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/lazyload.gif" data-original="/img/The_Nightwatch.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="高级数据结构"/></a><div class="content"><a class="title" href="/2023/07/31/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/" title="高级数据结构">高级数据结构</a><time datetime="2023-07-31T02:53:35.000Z" title="发表于 2023-07-31 10:53:35">2023-07-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/29/%E6%8E%92%E5%BA%8F%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95/" title="排序选择算法"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/lazyload.gif" data-original="/img/Figure_in_a_Room.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="排序选择算法"/></a><div class="content"><a class="title" href="/2023/01/29/%E6%8E%92%E5%BA%8F%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95/" title="排序选择算法">排序选择算法</a><time datetime="2023-01-29T09:59:49.000Z" title="发表于 2023-01-29 17:59:49">2023-01-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By 花瓶</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'e19706903ff8a3f54196',
      clientSecret: '6854f9b2fb4f13d47055fbbf869e0e815516840f',
      repo: 'robust-vase.github.io',
      owner: 'robust-vase',
      admin: ['robust-vase'],
      id: 'ba3f670f2c4be211fe4adfc0e6122cae',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.textContent= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script async src="/js/title.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,文明,平等,公正,法制,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/footer.js"></script><!-- hexo injector body_end end --><script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},t.src!==i&&(n.src=i)}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body></html>